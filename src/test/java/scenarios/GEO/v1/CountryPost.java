package scenarios.GEO.v1;

import java.io.IOException;
import java.lang.reflect.Method;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.log4j.xml.DOMConfigurator;
import org.json.JSONArray;
import org.json.JSONObject;
import org.testng.Assert;
import org.testng.SkipException;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.aventstack.extentreports.Status;
import com.aventstack.extentreports.markuputils.ExtentColor;
import com.aventstack.extentreports.markuputils.MarkupHelper;
import com.fedex.jms.client.reader.JMSReader;

import io.restassured.path.json.JsonPath;
import io.restassured.response.Response;
import utils.v1.DbConnect;
import utils.v1.ExcelUtil;
import utils.v1.Miscellaneous;
import utils.v1.Queries;
import utils.v1.Reporting;
import utils.v1.ResponseMessages;
import utils.v1.RetrieveEndPoints;
import utils.v1.TestResultValidation;
import utils.v1.ValidationFields;
import wsMethods.v1.GetResponse;
import wsMethods.v1.PostMethod;

public class CountryPost extends Reporting {

	private static final String formatTranslationGeopoliticalsEffectiveDate = null;
	String scenarioName = getClass().getSimpleName();
	String TestCaseDescription, scenarioType, userId, countryNumericCode, countryCode, threeCharacterCountryCode,
			independentFlag, postalFormatDescription, postalFlag, postalLengthNumber, firstWorkWeekDayName,
			lastWorkWeekDayName, weekendFirstDayName, internetDomainName, dependentRelationshipId, dependentCountryCode,
			countryEffectiveDate, countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
			moblPhMaxLthNbr, moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
			currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
			geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
			geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
			geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber,
			cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
			dateShortFormatDescription, localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
			translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
			translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
			phoneNumberFormatPattern;

	Queries query = new Queries();
	String fileName = this.getClass().getSimpleName();
	ExcelUtil ex = new ExcelUtil();
	String runFlag = null;
	String writableInputFields, writableDB_Fields = null, writableInputAuditFields, writableDBAuditFields = null,
			writableResult = null;
	ResponseMessages resMsgs = new ResponseMessages();
	JMSReader jmsReader = new JMSReader();
	static Logger logger = Logger.getLogger(CountryPost.class);
	String actuatorcommandversion;
	TestResultValidation resultValidation = new TestResultValidation();

	@BeforeClass
	public void before() {
		DOMConfigurator.configure("log4j.xml");
		// ***create test result excel file
		ex.createResultExcel(fileName);
		// *** getting actautor version
		String tokenKey = tokenValues[0];
		String tokenVal = token;
		/*
		 * String actuatorCommandeVersionURL =
		 * RetrieveEndPoints.getEndPointUrl("commandActuator", fileName, level +
		 * ".command.version"); //actuatorcommandversion =
		 * resultValidation.versionValidation(fileName, tokenKey, tokenVal,
		 * actuatorCommandeVersionURL);
		 */
		actuatorcommandversion = "1.0.0";
	}

	@BeforeMethod
	protected void startRepo(Method m) throws IOException {

		runFlag = getExecutionFlag(m.getName(), fileName);
		if (runFlag.equalsIgnoreCase("Yes")) {
			String testCaseName = m.getName();
			test = extent.createTest(testCaseName);
		}
	}

	@Test(priority = 1)
	public void TC_01() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		List<String> getResultAuditDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query
				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");
				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;
				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;
				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();
				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);

				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// ***Audit table DB query****//
				String cntryPostPostAuditQuery1 = query.cntryPostAuditQuery(countryCode, geoplId,
						formatCountryEffectiveDate, formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields = ValidationFields.cntryAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB1 = DbConnect.getResultSetFor(cntryPostPostAuditQuery1, auditFields,
						fileName, testCaseID);
				getResultAuditDBFinal.addAll(getResultAuditDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 */
				/*
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// ***Audit table DB query****//
				// String cntryPostAuditQuery2 =
				// query.cntryCountryDialingsPostAuditQuery(geoplId,
				// formatCountryDialingsEffectiveDate);
				// ***get the fields needs to be validate in DB
				// List<String> auditFields2 =
				// ValidationFields.cntryCountryDialingsAuditDbFields();
				// ***get the result from DB
				// List<String> getResultAuditDB2 =
				// DbConnect.getResultSetFor(cntryPostAuditQuery2, auditFields2,
				// fileName,
				// testCaseID);
				// ***send the input, response, DB result for validation
				// getResultAuditDBFinal.addAll(getResultAuditDB2);
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);
				// ***Audit table DB query****//
				String countryPostAuditQuery3 = query.cntryCurrenciesPostAuditQuery(geoplId, currencyCode,
						minorUnitCode, formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields3 = ValidationFields.cntryCurrenciesAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB3 = DbConnect.getResultSetFor(countryPostAuditQuery3, auditFields3,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB3);
				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;
				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();
				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);
				// ***Audit table DB query****//
				String countryPostAuditQuery4 = query.cntryGeopoliticalUOMPostAuditQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields4 = ValidationFields.cntryGeopoliticalUOMAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB4 = DbConnect.getResultSetFor(countryPostAuditQuery4, auditFields4,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB4);
				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);
				// ***Audit table DB query****//
				String countryPostAuditQuery5 = query.cntryGeopoliticalHolidaysPostAuditQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields5 = ValidationFields.cntryGeopoliticalHolidaysAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB5 = DbConnect.getResultSetFor(countryPostAuditQuery5, auditFields5,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB5);
				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);
				// ***Audit table DB query****//
				String countryPostAuditQuery6 = query.cuntryGeopoliticalAffiliationsPostAuditQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields6 = ValidationFields.cntryGeopoliticalAffiliationsAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB6 = DbConnect.getResultSetFor(countryPostAuditQuery6, auditFields6,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB6);

				// // Query 7--
				// String formatLocalesEffectiveDate = localesEffectiveDate;
				// Date dateLocalesEffectiveDate = null;
				//
				// try {
				// dateLocalesEffectiveDate =
				// srcDf.parse(formatLocalesEffectiveDate);
				// } catch (ParseException e) {
				// // TODO Auto-generated catch block
				// e.printStackTrace();
				// }
				// formatLocalesEffectiveDate =
				// destDf.format(dateLocalesEffectiveDate);
				// formatLocalesEffectiveDate =
				// formatLocalesEffectiveDate.toUpperCase();
				// String countryPostQuery7 =
				// query.cntryLocalesPostQuery(geoplId, localeCode,
				// formatLocalesEffectiveDate,
				// localesScriptCd);
				// // ***get the fields needs to be validate in DB
				// List<String> fields7 =
				// ValidationFields.cntryLocalesDbFields();
				// // ***get the result from DB
				// List<String> getResultDB7 =
				// DbConnect.getResultSetFor(countryPostQuery7, fields7,
				// fileName, testCaseID);
				// // ***send the input, response, DB result for validation
				// getResultDBFinal.addAll(getResultDB7);
				// // ***Audit table DB query****//
				// String countryPostAuditQuery7 =
				// query.cntryLocalesPostAuditQuery(geoplId, localeCode,
				// formatLocalesEffectiveDate, localesScriptCd);
				// // ***get the fields needs to be validate in DB
				// List<String> auditFields7 =
				// ValidationFields.cntryLocalesAuditDbFields();
				// // ***get the result from DB
				// List<String> getResultAuditDB7 =
				// DbConnect.getResultSetFor(countryPostAuditQuery7,
				// auditFields7,
				// fileName, testCaseID);
				// // ***send the input, response, DB result for validation
				// getResultAuditDBFinal.addAll(getResultAuditDB7);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// ***Audit table DB query***/
				String countryPostAuditQuery8 = query.cntryTranslationGeopoliticalsPostAuditQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> auditFields8 = ValidationFields.cntryTranslationGeopoliticalsAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB8 = DbConnect.getResultSetFor(countryPostAuditQuery8, auditFields8,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				// ***Audit table DB query****//
				String countryPostAuditQuery9 = query.countryGeopoliticalTypePostAuditQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> auditFields9 = ValidationFields.cntryGeopoliticalTypeAuditDbFields();
				// ***get the result from DB
				List<String> getResultAuditDB9 = DbConnect.getResultSetFor(countryPostAuditQuery9, auditFields9,
						fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultAuditDBFinal.addAll(getResultAuditDB9);
				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation
						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						System.out.println(inputFieldValues.length + "................." + getResultDBFinal.size());
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							String revisionTypeCd = "0";

							String[] inputAuditFieldValues = { userId, countryNumericCode, countryCode,
									threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
									postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
									internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
									landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
									phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
									revisionTypeCd, currencyNumericCode, currencyCode, minorUnitCode,
									moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
									revisionTypeCd, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
									geopoliticalUnitOfMeasuresExpirationDate, revisionTypeCd, holidayName,
									geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
									revisionTypeCd, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
									geopoliticalAffiliationsExpirationDate, revisionTypeCd,
									translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
									translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
									translationGeopoliticalsExpirationDate, revisionTypeCd, geopoliticalTypeName,
									revisionTypeCd };

							testResult = false;
							testResult = TestResultValidation.testValidationWithDB(res, inputAuditFieldValues,
									getResultAuditDBFinal, resFields);
							if (testResult) {

								ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
										writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1,
										"Pass", "");
								test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
								String[] inputAuditFieldNames = { "Input_UserName:", "Input_countryNumberCd:",
										"Input_countryCd:", "Input_threeCharCountryCd:", "Input_independentFlag:",
										"Input_postalFormatDescription:", "Input_postalFlag:",
										"Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
										"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:",
										"Input_internetDomainName:", "Input_dependentRelationshipId:",
										"Input_dependentCountryCd:", "Input_intialDialingCd:", "Input_landPhMaxLthNbr:",
										"Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:", "Input_moblPhMinLthNbr:",
										"Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
										"Input_countryExpirationDate:", "Input_LastUpdateUserName:",
										"Expected_RevisionTypeCd:", "Input_currencyNumberCd:", "Input_currencyCd:",
										"Input_minorUnitCd:", "Input_moneyFormatDescription:",
										"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:",
										"Expected_currenciesRevisionTypeCd:", "Input_uomTypeCd:",
										"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
										"Input_geopoliticalUnitOfMeasuresExpirationDate:",
										"Expected_geopoliticalUnitOfMeasuresRevisionTypeCd:", "Input_holidayName:",
										"Input_geopoliticalHolidaysEffectiveDate:",
										"Input_geopoliticalHolidaysExpirationDate:",
										"Expected_geopoliticalHolidaysRevisionTypeCd:", "Input_affilTypeCd:",
										"Input_geopoliticalAffiliationsEffectiveDate:",
										"Input_geopoliticalAffiliationsExpirationDate:",
										"Expected_geopoliticalAffiliationsRevisionTypeCd:",
										"Input_translationGeopoliticalsLanguageCd:",
										"Input_translationGeopoliticalsScriptCd:", "Input_translationName:",
										"Input_versionNumber:", "Input_versionDate:",
										"Input_translationGeopoliticalsEffectiveDate:",
										"Input_translationGeopoliticalsExpirationDate:",
										"Expected_translationGeopoliticalsRevisionTypeCd:",
										"Input_geopoliticalTypeName:", "Expected_geopoliticalTypeRevisionTypeCd:" };

								writableInputAuditFields = Miscellaneous.geoFieldInputNames(inputAuditFieldValues,
										inputAuditFieldNames);

								String[] dbAuditFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
										"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
										"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
										"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
										"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
										"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
										"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:",
										"Db_countryEffectiveDate:", "Db_countryExpirationDate:",
										"Db_LastUpdateUserName:", "Db_currencyNumberCd:", "Db_currencyCd:",
										"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
										"Db_currenciesExpirationDate:", "Db_currenciesRevisionTypeCd:", "Db_uomTypeCd:",
										"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
										"Db_geopoliticalUnitOfMeasuresExpirationDate:",
										"Db_geopoliticalUnitOfMeasuresRevisionTypeCd:", "Db_holidayName:",
										"Db_geopoliticalHolidaysEffectiveDate:",
										"Db_geopoliticalHolidaysExpirationDate:",
										"Db_geopoliticalHolidaysRevisionTypeCd:", "Db_affilTypeCd:",
										"Db_geopoliticalAffiliationsEffectiveDate:",
										"Db_geopoliticalAffiliationsExpirationDate:",
										"Db_geopoliticalAffiliationsRevisionTypeCd:",
										"Db_translationGeopoliticalsLanguageCd:",
										"Db_translationGeopoliticalsScriptCd:", "Db_translationName:",
										"Db_versionNumber:", "Db_versionDate:",
										"Db_translationGeopoliticalsEffectiveDate:",
										"Db_translationGeopoliticalsExpirationDate:",
										"Db_translationGeopoliticalsRevisionTypeCd:", "Db_geopoliticalTypeName:",
										"Db_geopoliticalTypeRevisionTypeCd:" };

								writableDBAuditFields = Miscellaneous.geoDBFieldNames(getResultAuditDBFinal,
										dbAuditFieldNames);
								test.info("***Audit Table Validation Starts***");
								test.info("Input Data Values:");
								test.info(writableInputAuditFields.replaceAll("\n", "<br />"));
								test.info("DB Audit Table Data Values:");
								test.info(writableDBAuditFields.replaceAll("\n", "<br />"));

								logger.info("Comparison between input data & DB data matching and passed");
								logger.info(
										"Execution is completed for Audit Table Passed Test Case No. " + testCaseID);
								logger.info("------------------------------------------------------------------");
								test.pass("Comparison between input data & DB Audit table data matching and passed");
								ex.writeExcel(fileName, testCaseID, "Audit Table Validation", scenarioType, "",
										writableInputAuditFields, writableDBAuditFields, "", "", "", "Pass",
										"Audit Table validation");
							}

						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {

				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_02() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation

				if (errorMsg1.get(0).equals("countryCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when sending the blank countryCode");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when sending the blank countryCode");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_03() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("countryNumericCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response  when the countryNumericCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response  when the countryNumericCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryNumericCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryNumericCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_04() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("threeCharacterCountryCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response  when the threeCharacterCountryCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response  when the threeCharacterCountryCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "threeCharacterCountryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "threeCharacterCountryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_05() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_06() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_07() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_08() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_09() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_10() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_11() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_12() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_13() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_14()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = "9999-12-21";
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_15() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_16() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_17() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						landPhMaxLthNbr = "";
						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_18() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						landPhMinLthNbr = "";
						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_19() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						moblPhMaxLthNbr = "";
						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_20() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						moblPhMinLthNbr = "";
						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_21() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_22() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.currencyNumberCodeNullMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("currencyNumericCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response  when the currencyNumericCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response  when the currencyNumericCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "currencyNumericCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "currencyNumericCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_23() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("currencyCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response  when the currencyCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the currencyCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "currencyCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "currencyCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_24() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("minorUnitCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the minorUnitCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the minorUnitCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "minorUnitCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "minorUnitCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_25() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_26() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = "9999-12-31";
				}

				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_27() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = "9999-12-31";
				}

				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)

	public void TC_28()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("uomTypeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the uomTypeCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the uomTypeCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "uomTypeCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "uomTypeCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_29() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				if (geopoliticalUnitOfMeasuresExpirationDate.isEmpty()) {
					geopoliticalUnitOfMeasuresExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_30() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				if (geopoliticalUnitOfMeasuresExpirationDate.isEmpty()) {
					geopoliticalUnitOfMeasuresExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;
				String formatGeopoliticalUnitOfMeasuresExpirationDate = geopoliticalUnitOfMeasuresExpirationDate;
				Date dateGeopoliticalUnitOfMeasuresExpirationDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
					dateGeopoliticalUnitOfMeasuresExpirationDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				formatGeopoliticalUnitOfMeasuresExpirationDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresExpirationDate);
				formatGeopoliticalUnitOfMeasuresExpirationDate = formatGeopoliticalUnitOfMeasuresExpirationDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_31()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("holidayName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the holidayName is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the holidayName is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "holidayName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "holidayName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_32() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				if (geopoliticalHolidaysExpirationDate.isEmpty()) {
					geopoliticalHolidaysExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_33() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				if (geopoliticalHolidaysExpirationDate.isEmpty()) {
					geopoliticalHolidaysExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				String formatGeopoliticalHolidaysExpirationDate = geopoliticalHolidaysExpirationDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;
				Date dateGeopoliticalHolidaysExpirationDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
					dateGeopoliticalHolidaysExpirationDate = srcDf.parse(formatGeopoliticalHolidaysExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				formatGeopoliticalHolidaysExpirationDate = destDf.format(dateGeopoliticalHolidaysExpirationDate);
				formatGeopoliticalHolidaysExpirationDate = formatGeopoliticalHolidaysExpirationDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_34()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("affiliationTypeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the affiliationTypeCd  is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the affiliationTypeCd  is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "affiliationTypeCd" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "affiliationTypeCd" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_35() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				if (geopoliticalAffiliationsExpirationDate.isEmpty()) {
					geopoliticalAffiliationsExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_36() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				if (geopoliticalAffiliationsExpirationDate.isEmpty()) {
					geopoliticalAffiliationsExpirationDate = "9999-12-31";
				}

				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				String formatGeopoliticalAffiliationsExpirationDate = geopoliticalAffiliationsExpirationDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;
				Date dateGeopoliticalAffiliationsExpirationDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
					dateGeopoliticalAffiliationsExpirationDate = srcDf
							.parse(formatGeopoliticalAffiliationsExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				formatGeopoliticalAffiliationsExpirationDate = destDf
						.format(dateGeopoliticalAffiliationsExpirationDate);
				formatGeopoliticalAffiliationsExpirationDate = formatGeopoliticalAffiliationsExpirationDate
						.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_37() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("languageCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the locale - languageCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the locale - languageCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_38() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("localeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the localeCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the localeCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "localeCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "localeCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_39() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_40() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_41() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_42() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_43() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_44() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_45() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_46() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_47()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation

				if (errorMsg1.get(0).equals("languageCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the Translation Geopolitical - languageCode is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the Translation Geopolitical - languageCode is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_48() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_49() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_50() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_51() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				if (translationGeopoliticalsExpirationDate.isEmpty()) {
					translationGeopoliticalsExpirationDate = "9999-12-31";
				}

				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_52() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				if (translationGeopoliticalsExpirationDate.isEmpty()) {
					translationGeopoliticalsExpirationDate = "9999-12-31";
				}

				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;
				String formatTranslationGeopoliticalsExpirationDate = translationGeopoliticalsExpirationDate;
				Date dateTranslationGeopoliticalsExpirationDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
					dateTranslationGeopoliticalsExpirationDate = srcDf
							.parse(formatTranslationGeopoliticalsExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				formatTranslationGeopoliticalsExpirationDate = destDf
						.format(dateTranslationGeopoliticalsExpirationDate);
				formatTranslationGeopoliticalsExpirationDate = formatTranslationGeopoliticalsExpirationDate
						.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_53()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("geopoliticalTypeName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the geopoliticalTypeName is passed as empty/ null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when thegeopoliticalTypeName is passed as empty/ null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_54() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutcountryNumberCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("countryNumericCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the countryNumericCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the countryNumericCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryNumericCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryNumericCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_55() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutCntryCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("countryCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the countryCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the countryCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_56() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutThreeCharCntryCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("threeCharacterCountryCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the threeCharacterCountryCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the threeCharacterCountryCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "threeCharacterCountryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "threeCharacterCountryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_57() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutIndependentFlag(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_58() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutPostalFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_59() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutPostalFlag(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate,
								/*
								 * localesLanguageCd, localeCode,
								 * localesScriptCd, cldrVersionNumber,
								 * cldrVersionDate, dateFullFormatDescription,
								 * dateLongFormatDescription,
								 * dateMediumFormatDescription,
								 * dateShortFormatDescription,
								 * localesEffectiveDate, localesExpirationDate,
								 */ translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
								translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
								translationGeopoliticalsExpirationDate, geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_60() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutPostalLengthNumber(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_61() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutFirstWorkWeekDayName(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_62() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutWeekendFirstDayName(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_63() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutInternetDomainName(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_64() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutDependentRelationshipId(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_65() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutDependentCountryCd(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_66() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutEffectiveDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate,
								/*
								 * localesLanguageCd, localeCode,
								 * localesScriptCd, cldrVersionNumber,
								 * cldrVersionDate, dateFullFormatDescription,
								 * dateLongFormatDescription,
								 * dateMediumFormatDescription,
								 * dateShortFormatDescription,
								 * localesEffectiveDate, localesExpirationDate,
								 */ translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
								translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
								translationGeopoliticalsExpirationDate, geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_67() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutExpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_68() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutIntialDialingCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_69() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutLandPhMaxLthNbr(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_70() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutlandPhMinLthNbr(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate,
								/*
								 * localesLanguageCd, localeCode,
								 * localesScriptCd, cldrVersionNumber,
								 * cldrVersionDate, dateFullFormatDescription,
								 * dateLongFormatDescription,
								 * dateMediumFormatDescription,
								 * dateShortFormatDescription,
								 * localesEffectiveDate, localesExpirationDate,
								 */ translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
								translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
								translationGeopoliticalsExpirationDate, geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_71() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutmoblPhMaxLthNbr(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_72() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutmoblPhMinLthNbr(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_73() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest_without_phoneNumberFormatPattern(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
					landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			int Wscode = res.statusCode();
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);
				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */
				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {

					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_currencyNumberCd:", "Db_currencyCd:",
								"Db_minorUnitCd:", "Db_moneyFormatDescription:", "Db_currenciesEffectiveDate:",
								"Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_74() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutCurrencyNumberCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.currencyNumberCodeNullMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("currencyNumericCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the currencyNumericCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the currencyNumericCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "currencyNumericCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "currencyNumericCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_75() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutCurrencyCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("currencyCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the currencyCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the currencyCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "currencyCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "currencyCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_76() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutminorUnitCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("minorUnitCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the minorUnitCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the minorUnitCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "minorUnitCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "minorUnitCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_77() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutMoneyFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_78() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestCurEffectiveDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_79() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestCurExpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_80() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutUomTypeCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("uomTypeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the uomTypeCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the uomTypeCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "uomTypeCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "uomTypeCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_81() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestUomEffectiveDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_82() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestUomExpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				if (geopoliticalUnitOfMeasuresExpirationDate.isEmpty()) {
					geopoliticalUnitOfMeasuresExpirationDate = "9999-12-31";
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_83() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutholidayName(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("holidayName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the holidayName attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the holidayName attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "holidayName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "holidayName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_84() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestHolidayeffectiveDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_85() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestHolidayexpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; }
				 *
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				if (geopoliticalHolidaysExpirationDate.isEmpty()) {
					geopoliticalHolidaysExpirationDate = "9999-12-31";
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_86() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutAffilTypeCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("affiliationTypeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the affiliationTypeCd attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the affiliationTypeCd attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "affiliationTypeCd" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "affiliationTypeCd" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_87() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutAffileffectiveDate(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_88() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutAffilexpirationDate(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				if (geopoliticalAffiliationsExpirationDate.isEmpty()) {
					geopoliticalAffiliationsExpirationDate = "9999-12-31";
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_89() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutLocaleLanguageCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("languageCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the locale - languageCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the locale - languageCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));

				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_90() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutLocaleCd(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("localeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the localeCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the localeCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "localeCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "localeCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_91() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutcldrVersionNumber(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_92() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutcldrVersionDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_93() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutdateFullFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_94() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutdateLongFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_95() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutdateMediumFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_96() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutdateShortFormatDescription(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_97() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutLocaleEffectiveDate(userId, countryNumericCode,
					countryCode, threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
					postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
					internetDomainName, dependentRelationshipId, dependentCountryCode, countryEffectiveDate,
					countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr,
					moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
					currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:",

								"Db_translationGeopoliticalsLanguageCd:", "Db_translationGeopoliticalsScriptCd:",
								"Db_translationName:", "Db_versionNumber:", "Db_versionDate:",
								"Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_98() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestLocaleExpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);

				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_99() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithouttranslationGeopoliticalsLangCd(userId,
					countryNumericCode, countryCode, threeCharacterCountryCode, independentFlag,
					postalFormatDescription, postalFlag, postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName,
					weekendFirstDayName, internetDomainName, dependentRelationshipId, dependentCountryCode,
					countryEffectiveDate, countryExpirationDate, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, currencyNumericCode, currencyCode, minorUnitCode,
					moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
					geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate, holidayName,
					geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate, affiliationTypeCd,
					geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate, localesLanguageCd,
					localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
					dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
					localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
					translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
					translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate, geopoliticalTypeName,
					phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("languageCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the Translation Geopolitical - languageCode attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the Translation Geopolitical - languageCode attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "languageCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_100() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutTranslationName(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_101() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutTGversionNumber(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_102() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutTGversionDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2

				/*
				 * String formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--
				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_103() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutTGeffectiveDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = todaysDate;
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					currenciesExpirationDate = todaysDate;
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");

						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_104() {

		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		List<String> getResultDBFinal = new ArrayList<String>();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestTGexpirationDate(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);

			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String geoplId = js.get("data.geopoliticalId").toString();
			String Wsstatus = js.getString("meta.message.status");
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 200 && Wsstatus.equalsIgnoreCase("SUCCESS") && meta != null
					&& actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status validation passed: " + Wscode);
				test.pass("Response status validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***get the DB query
				Date date = new Date();
				String todaysDate = new SimpleDateFormat("yyyy-MM-dd").format(date);

				DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
				DateFormat destDf = new SimpleDateFormat("dd-MMM-yyyy");

				// Query1
				if (countryEffectiveDate.isEmpty()) {
					countryEffectiveDate = todaysDate;
				}
				if (countryExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}

				String formatCountryEffectiveDate = countryEffectiveDate;
				String formatCountryExpirationDate = countryExpirationDate;

				Date dateCountryEffectiveDate = null;
				Date dateCountryExpirationDate = null;

				try {
					dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
					dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
				formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

				formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
				formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

				String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geoplId, formatCountryEffectiveDate,
						formatCountryExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields = ValidationFields.cntryDbFields();
				// ***get the result from DB
				List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
						testCaseID);
				getResultDBFinal.addAll(getResultDB1);

				// Query 2
				/*
				 * if (countryDialingsEffectiveDate.isEmpty()) {
				 * countryDialingsEffectiveDate = todaysDate; } String
				 * formatCountryDialingsEffectiveDate =
				 * countryDialingsEffectiveDate; Date
				 * dateCountryDialingsEffectiveDate = null;
				 *
				 * try { dateCountryDialingsEffectiveDate =
				 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
				 * (ParseException e) { // TODO Auto-generated catch block
				 * e.printStackTrace(); }
				 *
				 * formatCountryDialingsEffectiveDate =
				 * destDf.format(dateCountryDialingsEffectiveDate);
				 * formatCountryDialingsEffectiveDate =
				 * formatCountryDialingsEffectiveDate.toUpperCase();
				 *
				 * String cntryPostQuery2 =
				 * query.cntryCountryDialingsPostQuery(geoplId,
				 * formatCountryDialingsEffectiveDate); // ***get the fields
				 * needs to be validate in DB List<String> fields2 =
				 * ValidationFields.cntryCountryDialingsDbFields(); // ***get
				 * the result from DB List<String> getResultDB2 =
				 * DbConnect.getResultSetFor(cntryPostQuery2, fields2, fileName,
				 * testCaseID); // ***send the input, response, DB result for
				 * validation getResultDBFinal.addAll(getResultDB2);
				 */

				// Query 3--
				if (currenciesEffectiveDate.isEmpty()) {
					currenciesEffectiveDate = todaysDate;
				}
				if (currenciesExpirationDate.isEmpty()) {
					countryExpirationDate = "9999-12-31";
				}
				String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
				String formatCurrenciesExpirationDate = currenciesExpirationDate;
				Date dateCurrenciesEffectiveDate = null;
				Date dateCurrenciesExpirationDate = null;
				try {
					dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
					dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
				formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

				formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
				formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

				String countryPostQuery3 = query.cntryCurrenciesPostQuery(geoplId, currencyCode, minorUnitCode,
						formatCurrenciesEffectiveDate, formatCurrenciesExpirationDate);
				// ***get the fields needs to be validate in DB
				List<String> fields3 = ValidationFields.cntryCurrenciesDbFields();
				// ***get the result from DB
				List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB3);

				// Query 4--
				if (geopoliticalUnitOfMeasuresEffectiveDate.isEmpty()) {
					geopoliticalUnitOfMeasuresEffectiveDate = todaysDate;
				}
				String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
				Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

				try {
					dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
							.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
						.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
				formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
						.toUpperCase();

				String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geoplId,
						formatGeopoliticalUnitOfMeasuresEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields4 = ValidationFields.cntryGeopoliticalUOMDbFields();
				// ***get the result from DB
				List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB4);

				// Query 5--
				if (geopoliticalHolidaysEffectiveDate.isEmpty()) {
					geopoliticalHolidaysEffectiveDate = todaysDate;
				}
				String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
				Date dateGeopoliticalHolidaysEffectiveDate = null;

				try {
					dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
				formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

				String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geoplId,
						formatGeopoliticalHolidaysEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields5 = ValidationFields.cntryGeopoliticalHolidaysDbFields();
				// ***get the result from DB
				List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB5);

				// Query 6--
				if (geopoliticalAffiliationsEffectiveDate.isEmpty()) {
					geopoliticalAffiliationsEffectiveDate = todaysDate;
				}
				String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
				Date dateGeopoliticalAffiliationsEffectiveDate = null;

				try {
					dateGeopoliticalAffiliationsEffectiveDate = srcDf
							.parse(formatGeopoliticalAffiliationsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatGeopoliticalAffiliationsEffectiveDate = destDf.format(dateGeopoliticalAffiliationsEffectiveDate);
				formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate.toUpperCase();

				String countryPostQuery6 = query.cuntryGeopoliticalAffiliationsPostQuery(geoplId,
						formatGeopoliticalAffiliationsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields6 = ValidationFields.cntryGeopoliticalAffiliationsDbFields();
				// ***get the result from DB
				List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB6);

				// Query 8--
				if (translationGeopoliticalsEffectiveDate.isEmpty()) {
					translationGeopoliticalsEffectiveDate = todaysDate;
				}
				if (translationGeopoliticalsExpirationDate.isEmpty()) {
					translationGeopoliticalsExpirationDate = "9999-12-31";
				}
				String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
				Date dateTranslationGeopoliticalsEffectiveDate = null;

				try {
					dateTranslationGeopoliticalsEffectiveDate = srcDf
							.parse(formatTranslationGeopoliticalsEffectiveDate);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				formatTranslationGeopoliticalsEffectiveDate = destDf.format(dateTranslationGeopoliticalsEffectiveDate);
				formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate.toUpperCase();

				String countryPostQuery8 = query.cntryTranslationGeopoliticalsPostQuery(geoplId,
						translationGeopoliticalsLanguageCd, formatTranslationGeopoliticalsEffectiveDate);
				// ***get the fields needs to be validate in DB
				List<String> fields8 = ValidationFields.cntryTranslationGeopoliticalsDbFields();
				// ***get the result from DB
				List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB8);

				// Query 9--

				String countryPostQuery9 = query.countryGeopoliticalTypePostQuery(geoplId);
				// ***get the fields needs to be validate in DB
				List<String> fields9 = ValidationFields.cntryGeopoliticalTypeDbFields();
				// ***get the result from DB
				List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName, testCaseID);
				// ***send the input, response, DB result for validation
				getResultDBFinal.addAll(getResultDB9);

				if (js.getString("data.geopoliticalId") != null) {
					String geoplId1 = js.getString("data.geopoliticalId");
					// ***success message validation
					String expectMessage = resMsgs.cntryNewPostSuccessMsg + geoplId1;
					if (internalMsg.equals(expectMessage)) {
						logger.info("Success response is getting received with Country Code: " + countryCode);
						test.pass("Success response is getting received with Country Code: " + countryCode);
						// ***send the input, response, DB result for validation

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						// ***get response fields values
						List<String> resFields = ValidationFields.langResponseFileds(res);
						logger.info("Country Table Validation Starts:");
						test.info("Country Table Validation Starts:");
						testResult = TestResultValidation.testValidationWithDB(res, inputFieldValues, getResultDBFinal,
								resFields);
						// ***write result to excel
						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:",
								"Input_translationGeopoliticalsLanguageCd:", "Input_translationGeopoliticalsScriptCd:",
								"Input_translationName:", "Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);

						String[] dbFieldNames = { "Db_UserName:", "Db_countryNumberCd:", "Db_countryCd:",
								"Db_threeCharCountryCd:", "Db_independentFlag:", "Db_postalFormatDescription:",
								"Db_postalFlag:", "Db_postalLengthNumber:", "Db_firstWorkWeekDayName:",
								"Db_lastWorkWeekDayName:", "Db_weekendFirstDayName:", "Db_internetDomainName:",
								"Db_dependentRelationshipId:", "Db_dependentCountryCd:", "Db_intialDialingCd:",
								"Db_landPhMaxLthNbr:", "Db_landPhMinLthNbr:", "Db_moblPhMaxLthNbr:",
								"Db_moblPhMinLthNbr:", "Db_phoneNumberFormatPattern:", "Db_countryEffectiveDate:",
								"Db_countryExpirationDate:", "Db_LastUpdateUserName:", "Db_currencyNumberCd:",
								"Db_currencyCd:", "Db_minorUnitCd:", "Db_moneyFormatDescription:",
								"Db_currenciesEffectiveDate:", "Db_currenciesExpirationDate:", "Db_uomTypeCd:",
								"Db_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Db_geopoliticalUnitOfMeasuresExpirationDate:", "Db_holidayName:",
								"Db_geopoliticalHolidaysEffectiveDate:", "Db_geopoliticalHolidaysExpirationDate:",
								"Db_affilTypeCd:", "Db_geopoliticalAffiliationsEffectiveDate:",
								"Db_geopoliticalAffiliationsExpirationDate:", "Db_translationGeopoliticalsLanguageCd:",
								"Db_translationGeopoliticalsScriptCd:", "Db_translationName:", "Db_versionNumber:",
								"Db_versionDate:", "Db_translationGeopoliticalsEffectiveDate:",
								"Db_translationGeopoliticalsExpirationDate:", "Db_geopoliticalTypeName:" };

						writableDB_Fields = Miscellaneous.geoDBFieldNames(getResultDBFinal, dbFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						test.info("DB Data Values:");
						test.info(writableDB_Fields.replaceAll("\n", "<br />"));
						if (testResult) {
							logger.info("Comparison between input data & DB data matching and passed");
							logger.info("------------------------------------------------------------------");
							test.pass("Comparison between input data & DB data matching and passed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Pass",
									"");
						} else {
							logger.error("Comparison between input data & DB data not matching and failed");
							logger.error("------------------------------------------------------------------");
							test.fail("Comparison between input data & DB data not matching and failed");
							ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
									writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
									"Comparison between input data & DB data not matching and failed");
							Assert.fail("Test Failed");
						}
					} else {
						logger.error("Success message is not getting received as expected in response");
						test.fail("Success message is not getting received as expected in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, writableDB_Fields, Wsstatus, "" + Wscode, responsestr1, "Fail",
								"Success message is not getting received as expected in response");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("geoplId  is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("geoplId is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr1, "Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 200) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr1, "Fail", internalMsg);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_105() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutGeoTypeNm(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("geopoliticalTypeName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the geopoliticalTypeName attribute is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the geopoliticalTypeName attribute is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_106() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutMeta(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("meta") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the Metadata section is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the Metadata section is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "meta" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "meta" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_107() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("userName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the username is passed as empty/null in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the username is passed as empty/null in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "userName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "userName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_108() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestWithoutUserName(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, countryEffectiveDate, countryExpirationDate,
					intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
					currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.requiredFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("userName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when the username is not passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when the username is not passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "userName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "userName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_109()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("dependentRelationshipId") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid dependentRelationshipId  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid dependentRelationshipId  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_110()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String internalMsg = js.getString("meta.message.internalMessage");
			int Wscode = res.statusCode();
			String Wsstatus = res.getStatusLine();
			if (internalMsg.contains("Resource Not Found") && Wscode == 404) {
				int errrorMsgLength = js.get("errors.size");
				List<String> errorMsg1 = new ArrayList<String>();
				List<String> errorMsg2 = new ArrayList<String>();
				for (int i = 0; i < errrorMsgLength; i++) {
					errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
					errorMsg2.add(js.getString("errors[" + i + "].message"));
				}
				String expectMessage = resMsgs.inValidFieldMsg;
				String meta = js.getString("meta");
				String actualRespVersionNum = js.getString("meta.version");
				if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.info("Response status code 404 validation passed: " + Wscode);
					test.pass("Response status code 404 validation passed: " + Wscode);
					test.pass("Response meta validation passed");

					test.pass("Response API version number validation passed");
					ValidationFields.timestampValidation(js, res);
					ValidationFields.transactionIdValidation(js, res);
					// ***error message validation
					if (errorMsg1.get(0).equals("dependentCountryCode") && errorMsg2.get(0).equals(expectMessage)) {

						String[] inputFieldValues = { userId, countryNumericCode, countryCode,
								threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag,
								postalLengthNumber, firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName,
								internetDomainName, dependentRelationshipId, dependentCountryCode, intialDialingCd,
								landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr,
								phoneNumberFormatPattern, countryEffectiveDate, countryExpirationDate, userId,
								currencyNumericCode, currencyCode, minorUnitCode, moneyFormatDescription,
								currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
								geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
								holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
								affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
								geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
								cldrVersionNumber, cldrVersionDate, dateFullFormatDescription,
								dateLongFormatDescription, dateMediumFormatDescription, dateShortFormatDescription,
								localesEffectiveDate, localesExpirationDate, translationGeopoliticalsLanguageCd,
								translationGeopoliticalsScriptCd, translationName, versionNumber, versionDate,
								translationGeopoliticalsEffectiveDate, translationGeopoliticalsExpirationDate,
								geopoliticalTypeName };

						String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
								"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
								"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
								"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
								"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
								"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
								"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:",
								"Input_countryEffectiveDate:", "Input_countryExpirationDate:",
								"Input_LastUpdateUserName:", "Input_currencyNumberCd:", "Input_currencyCd:",
								"Input_minorUnitCd:", "Input_moneyFormatDescription:", "Input_currenciesEffectiveDate:",
								"Input_currenciesExpirationDate:", "Input_uomTypeCd:",
								"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
								"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
								"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
								"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
								"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
								"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
								"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
								"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
								"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
								"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
								"Input_translationGeopoliticalsScriptCd:", "Input_translationName:",
								"Input_versionNumber:", "Input_versionDate:",
								"Input_translationGeopoliticalsEffectiveDate:",
								"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

						writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
						test.info("Input Data Values:");
						test.info(writableInputFields.replaceAll("\n", "<br />"));
						logger.info(
								"Expected error message is getting received in response when invalid dependentCountryCode  is passed in the JSON request");
						logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
						logger.info("------------------------------------------------------------------");
						test.pass(
								"Expected error message is getting received in response when invalid dependentCountryCode  is passed in the JSON request");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
								writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
						test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
					} else {
						logger.error("Expected error message is not getting received in response");
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Expected error message is not getting received in response");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
								Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
						Assert.fail("Test Failed");
					}
				} else {
					if (Wscode != 404) {
						logger.error("Response status validation failed: " + Wscode);
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Response status validation failed: " + Wscode);
					} else if (meta == null) {
						logger.error("Response validation failed as meta not present");
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Response validation failed as meta not present");
					} else if (meta.contains("timestamp")) {
						logger.error("Response validation failed as timestamp is present");
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Response validation failed as timestamp is present");
					} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
						logger.error("Response validation failed as API version number is not matching with expected");
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Response validation failed as API version number is not matching with expected");
					}

					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				logger.error("Expected error message is not getting received in response");
				logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
				logger.error("------------------------------------------------------------------");
				test.fail("Expected error message is not getting received in response");
				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "");
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_111()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("uomTypeCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid uomTypeCode  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid uomTypeCode  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_112()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("holidayName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid holidayName  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid holidayName  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_113()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("affiliationTypeCd") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid affiliationTypeCd  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid affiliationTypeCd  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_114()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("languageCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid languageCode  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid languageCode  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_115()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("scriptCode") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid scriptCode  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid scriptCode  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 3)
	public void TC_116()

	{
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.inValidFieldMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 404 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 404 validation passed: " + Wscode);
				test.pass("Response status code 404 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation
				if (errorMsg1.get(0).equals("geopoliticalTypeName") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when invalid geopoliticalTypeName  is passed in the JSON request");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when invalid geopoliticalTypeName  is passed in the JSON request");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 404) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "geopoliticalTypeName" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_117() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequestMissingComma(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, tokenValues[0], token, getEndPoinUrl, fileName,
					testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.missingCommaInRequestMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 400 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 400 validation passed: " + Wscode);
				test.pass("Response status code 400 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation

				if (errorMsg1.get(0).equals("Error") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when sending the blank countryCode");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when sending the blank countryCode");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_118() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			/*
			 * Response res = GetResponse.sendRequestPost(payload,
			 * tokenValues[0], token, getEndPoinUrl, fileName, testCaseID);
			 */
			Response res = GetResponse.sendRequestGet(tokenValues[0], token, getEndPoinUrl, fileName, testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.usedGETinCommanderrorMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 405 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 405 validation passed: " + Wscode);
				test.pass("Response status code 405 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation

				if (errorMsg1.get(0).equals("Error") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when sending the blank countryCode");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when sending the blank countryCode");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 2)
	public void TC_119() {
		// ***get test case ID with method name
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));
			// ***send the data to create request and get request
			String payload = PostMethod.cntryPostRequest(userId, countryNumericCode, countryCode,
					threeCharacterCountryCode, independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
					firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
					dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr, landPhMinLthNbr,
					moblPhMaxLthNbr, moblPhMinLthNbr, countryEffectiveDate, countryExpirationDate, currencyNumericCode,
					currencyCode, minorUnitCode, moneyFormatDescription, currenciesEffectiveDate,
					currenciesExpirationDate, uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
					geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
					geopoliticalHolidaysExpirationDate, affiliationTypeCd, geopoliticalAffiliationsEffectiveDate,
					geopoliticalAffiliationsExpirationDate, localesLanguageCd, localeCode, localesScriptCd,
					cldrVersionNumber, cldrVersionDate, dateFullFormatDescription, dateLongFormatDescription,
					dateMediumFormatDescription, dateShortFormatDescription, localesEffectiveDate,
					localesExpirationDate, translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd,
					translationName, versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
					translationGeopoliticalsExpirationDate, geopoliticalTypeName, phoneNumberFormatPattern);
			String reqFormatted = Miscellaneous.jsonFormat(payload);
			test.info("Input Request created:");
			test.info(reqFormatted.replaceAll("\n", "<br />"));
			// ***get end point url
			String getEndPoinUrl = RetrieveEndPoints.getEndPointUrl("geoPost", fileName, level + ".cntry.post");
			// ***send request and get response
			Response res = GetResponse.sendRequestPost(payload, "", token, getEndPoinUrl, fileName, testCaseID);
			String responsestr = res.asString();
			String responsestr1 = Miscellaneous.jsonFormat(responsestr);
			test.info("Response Recieved:");
			test.info(responsestr1.replaceAll("\n", "<br />"));
			JsonPath js = new JsonPath(responsestr);
			String Wsstatus = res.getStatusLine();
			int errrorMsgLength = js.get("errors.size");
			List<String> errorMsg1 = new ArrayList<String>();
			List<String> errorMsg2 = new ArrayList<String>();
			for (int i = 0; i < errrorMsgLength; i++) {
				errorMsg1.add(js.getString("errors[" + i + "].fieldName"));
				errorMsg2.add(js.getString("errors[" + i + "].message"));
			}
			int Wscode = res.statusCode();
			String expectMessage = resMsgs.missingHTTPHeaderInRequestMsg;
			String meta = js.getString("meta");
			String actualRespVersionNum = js.getString("meta.version");
			if (Wscode == 401 && meta != null && actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
				logger.info("Response status code 401 validation passed: " + Wscode);
				test.pass("Response status code 401 validation passed: " + Wscode);
				test.pass("Response meta validation passed");

				test.pass("Response API version number validation passed");
				ValidationFields.timestampValidation(js, res);
				ValidationFields.transactionIdValidation(js, res);
				// ***error message validation

				if (errorMsg1.get(0).equals("NA") && errorMsg2.get(0).equals(expectMessage)) {

					String[] inputFieldValues = { userId, countryNumericCode, countryCode, threeCharacterCountryCode,
							independentFlag, postalFormatDescription, postalFlag, postalLengthNumber,
							firstWorkWeekDayName, lastWorkWeekDayName, weekendFirstDayName, internetDomainName,
							dependentRelationshipId, dependentCountryCode, intialDialingCd, landPhMaxLthNbr,
							landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr, phoneNumberFormatPattern,
							countryEffectiveDate, countryExpirationDate, userId, currencyNumericCode, currencyCode,
							minorUnitCode, moneyFormatDescription, currenciesEffectiveDate, currenciesExpirationDate,
							uomTypeCode, geopoliticalUnitOfMeasuresEffectiveDate,
							geopoliticalUnitOfMeasuresExpirationDate, holidayName, geopoliticalHolidaysEffectiveDate,
							geopoliticalHolidaysExpirationDate, affiliationTypeCd,
							geopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate,
							localesLanguageCd, localeCode, localesScriptCd, cldrVersionNumber, cldrVersionDate,
							dateFullFormatDescription, dateLongFormatDescription, dateMediumFormatDescription,
							dateShortFormatDescription, localesEffectiveDate, localesExpirationDate,
							translationGeopoliticalsLanguageCd, translationGeopoliticalsScriptCd, translationName,
							versionNumber, versionDate, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeName };

					String[] inputFieldNames = { "Input_UserName:", "Input_countryNumberCd:", "Input_countryCd:",
							"Input_threeCharCountryCd:", "Input_independentFlag:", "Input_postalFormatDescription:",
							"Input_postalFlag:", "Input_postalLengthNumber:", "Input_firstWorkWeekDayName:",
							"Input_lastWorkWeekDayName:", "Input_weekendFirstDayName:", "Input_internetDomainName:",
							"Input_dependentRelationshipId:", "Input_dependentCountryCd:", "Input_intialDialingCd:",
							"Input_landPhMaxLthNbr:", "Input_landPhMinLthNbr:", "Input_moblPhMaxLthNbr:",
							"Input_moblPhMinLthNbr:", "Input_phoneNumberFormatPattern:", "Input_countryEffectiveDate:",
							"Input_countryExpirationDate:", "Input_LastUpdateUserName:", "Input_currencyNumberCd:",
							"Input_currencyCd:", "Input_minorUnitCd:", "Input_moneyFormatDescription:",
							"Input_currenciesEffectiveDate:", "Input_currenciesExpirationDate:", "Input_uomTypeCd:",
							"Input_geopoliticalUnitOfMeasuresEffectiveDate:",
							"Input_geopoliticalUnitOfMeasuresExpirationDate:", "Input_holidayName:",
							"Input_geopoliticalHolidaysEffectiveDate:", "Input_geopoliticalHolidaysExpirationDate:",
							"Input_affilTypeCd:", "Input_geopoliticalAffiliationsEffectiveDate:",
							"Input_geopoliticalAffiliationsExpirationDate:", "Input_localesLanguageCd:",
							"Input_localeCd:", "Input_localesScriptCd:", "Input_cldrVersionNumber:",
							"Input_cldrVersionDate:", "Input_dateFullFormatDescription:",
							"Input_dateLongFormatDescription:", "Input_dateMediumFormatDescription:",
							"Input_dateShortFormatDescription:", "Input_localesEffectiveDate:",
							"Input_localesExpirationDate:", "Input_translationGeopoliticalsLanguageCd:",
							"Input_translationGeopoliticalsScriptCd:", "Input_translationName:", "Input_versionNumber:",
							"Input_versionDate:", "Input_translationGeopoliticalsEffectiveDate:",
							"Input_translationGeopoliticalsExpirationDate:", "Input_geopoliticalTypeName:" };

					writableInputFields = Miscellaneous.geoFieldInputNames(inputFieldValues, inputFieldNames);
					test.info("Input Data Values:");
					test.info(writableInputFields.replaceAll("\n", "<br />"));
					logger.info(
							"Expected error message is getting received in response when sending the blank countryCode");
					logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
					logger.info("------------------------------------------------------------------");
					test.pass(
							"Expected error message is getting received in response when sending the blank countryCode");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted,
							writableInputFields, "NA", Wsstatus, "" + Wscode, responsestr1, "Pass", "");
					test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
				} else {
					logger.error("Expected error message is not getting received in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Expected error message is not getting received in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "",
							Wsstatus, "" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
					Assert.fail("Test Failed");
				}
			} else {
				if (Wscode != 400) {
					logger.error("Response status validation failed: " + Wscode);
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response status validation failed: " + Wscode);
				} else if (meta == null) {
					logger.error("Response validation failed as meta not present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as meta not present");
				} else if (meta.contains("timestamp")) {
					logger.error("Response validation failed as timestamp is present");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as timestamp is present");
				} else if (!actualRespVersionNum.equalsIgnoreCase(actuatorcommandversion)) {
					logger.error("Response validation failed as API version number is not matching with expected");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Response validation failed as API version number is not matching with expected");
				}

				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, reqFormatted, "", "", Wsstatus,
						"" + Wscode, responsestr, "Fail", "countryCode" + expectMessage);
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	@Test(priority = 1)
	public void TC_120() {
		String testCaseID = new Object() {
		}.getClass().getEnclosingMethod().getName();
		logger.info("Executing Test Case: " + testCaseID);
		List<String> getResultDBFinal = new ArrayList<String>();
		if (!runFlag.equalsIgnoreCase("Yes")) {
			logger.info("Skipped Test Case No. " + testCaseID);
			logger.info("------------------------------------------------------------------");
			throw new SkipException("Execution skipped as per test flag set");
		}
		boolean testResult = false;
		// ***get test case ID with method name
		try {
			// ***get the test data from sheet
			testDataFields(scenarioName, testCaseID);
			test.log(Status.INFO, MarkupHelper.createLabel(TestCaseDescription, ExtentColor.PURPLE));

			// ***send request and get response

			JSONObject getJMSResult = jmsReader.messageGetsPublished("COUNTRY");

			if (getJMSResult != null) {

				String reqFormatted = Miscellaneous.jsonFormat(getJMSResult.toString());
				test.info("JMS Response Recieved:");
				test.info(reqFormatted.replaceAll("\n", "<br />"));

				String independentFlag, postalFormatDescription, postalFlag, firstWorkWeekDayName, lastWorkWeekDayName,
						weekendFirstDayName, internetDomainName;
				int postalLengthNumber;
				long dependentRelationshipId, dependentCountryCode;
				String dependentRelationshipId1, postalLengthNumber1, dependentCountryCd1;
				Object landPhMaxLthNbr, landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr;
				// int landPhMinLthNbr, moblPhMaxLthNbr, moblPhMinLthNbr;
				String landPhMaxLthNbr1 = null, landPhMinLthNbr1 = null, moblPhMaxLthNbr1 = null,
						moblPhMinLthNbr1 = null;
				Long geopoliticalId = getJMSResult.getJSONObject("data").getLong("geopoliticalId");
				Integer countryNumericCode = getJMSResult.getJSONObject("data").getInt("countryNumericCode");
				String countryCode = getJMSResult.getJSONObject("data").getString("countryCode");
				String threeCharacterCountryCode = getJMSResult.getJSONObject("data")
						.getString("threeCharacterCountryCode");
				if (getJMSResult.getJSONObject("data").isNull("independentFlag")) {
					independentFlag = "";
				} else {
					independentFlag = getJMSResult.getJSONObject("data").getString("independentFlag");
				}
				if (getJMSResult.getJSONObject("data").isNull("postalFormatDescription")) {
					postalFormatDescription = "";
				} else {
					postalFormatDescription = getJMSResult.getJSONObject("data").getString("postalFormatDescription");
				}
				if (getJMSResult.getJSONObject("data").isNull("postalFlag")) {
					postalFlag = "";
				} else {
					postalFlag = getJMSResult.getJSONObject("data").getString("postalFlag");
				}

				if (getJMSResult.getJSONObject("data").isNull("postalLength")) {
					postalLengthNumber1 = "";
				} else {
					postalLengthNumber = getJMSResult.getJSONObject("data").getInt("postalLength");
					postalLengthNumber1 = String.valueOf(postalLengthNumber);
				}

				if (getJMSResult.getJSONObject("data").isNull("firstWorkWeekDayName")) {
					firstWorkWeekDayName = "";
				} else {
					firstWorkWeekDayName = getJMSResult.getJSONObject("data").getString("firstWorkWeekDayName");
				}

				if (getJMSResult.getJSONObject("data").isNull("lastWorkWeekDayName")) {
					lastWorkWeekDayName = "";
				} else {
					lastWorkWeekDayName = getJMSResult.getJSONObject("data").getString("lastWorkWeekDayName");
				}

				if (getJMSResult.getJSONObject("data").isNull("weekendFirstDayName")) {
					weekendFirstDayName = null;
				} else {
					weekendFirstDayName = getJMSResult.getJSONObject("data").getString("weekendFirstDayName");
				}

				if (getJMSResult.getJSONObject("data").isNull("internetDomainName")) {
					internetDomainName = "";
				} else {
					internetDomainName = getJMSResult.getJSONObject("data").getString("internetDomainName");
				}

				if (getJMSResult.getJSONObject("data").isNull("dependentRelationshipId")) {
					// dependentRelationshipId = (Long) null;
					dependentRelationshipId1 = "";
				} else {
					dependentRelationshipId = getJMSResult.getJSONObject("data").getLong("dependentRelationshipId");
					dependentRelationshipId1 = String.valueOf(dependentRelationshipId);
				}

				if (getJMSResult.getJSONObject("data").isNull("dependentCountryCode")) {
					dependentCountryCd1 = "";
				} else {
					dependentCountryCode = getJMSResult.getJSONObject("data").getLong("dependentCountryCode");
					dependentCountryCd1 = String.valueOf(dependentCountryCode);
				}
				String intialDialingCd = getJMSResult.getJSONObject("data").optString("internationalDialingCode");
				if (getJMSResult.getJSONObject("data").isNull("landPhoneMaximumLength")) {
					landPhMaxLthNbr = null;
				} else {
					landPhMaxLthNbr = getJMSResult.getJSONObject("data").getInt("landPhoneMaximumLength");
					landPhMaxLthNbr1 = String.valueOf(landPhMaxLthNbr);
				}

				if (getJMSResult.getJSONObject("data").isNull("landPhoneMinimumLength")) {
					landPhMinLthNbr = null;
				} else {
					landPhMinLthNbr = getJMSResult.getJSONObject("data").getInt("landPhoneMinimumLength");
					landPhMinLthNbr1 = String.valueOf(landPhMinLthNbr);
				}

				if (getJMSResult.getJSONObject("data").isNull("mobilePhoneMaximumLength")) {
					moblPhMaxLthNbr = null;
				} else {
					moblPhMaxLthNbr = getJMSResult.getJSONObject("data").getInt("mobilePhoneMaximumLength");
					moblPhMaxLthNbr1 = String.valueOf(moblPhMaxLthNbr);
				}

				if (getJMSResult.getJSONObject("data").isNull("mobilePhoneMinimumLength")) {
					moblPhMinLthNbr = null;
				} else {
					moblPhMinLthNbr = getJMSResult.getJSONObject("data").getInt("mobilePhoneMinimumLength");
					moblPhMinLthNbr1 = String.valueOf(moblPhMinLthNbr);
				}
				String countryEffectiveDate = getJMSResult.getJSONObject("data").getString("effectiveDate");
				String countryExpirationDate = getJMSResult.getJSONObject("data").getString("expirationDate");
				/**
				 * For retrieving the data from Country Dialings JSON array, we
				 * use optString() method after creating a JSONArray of Country
				 * Dialings. As first {} means 0th index of the array, we create
				 * JSON object of 0th index.
				 */
				/*
				 * JSONArray countryDialings =
				 * getJMSResult.getJSONObject("data").getJSONArray(
				 * "countryDialings"); JSONObject countryDialingsArray=
				 * countryDialings.getJSONObject(0); int
				 * landPhMaxLthNbr,landPhMinLthNbr,moblPhMaxLthNbr,
				 * moblPhMinLthNbr; String landPhMaxLthNbr1=
				 * null,landPhMinLthNbr1= null,moblPhMaxLthNbr1 =
				 * null,moblPhMinLthNbr1= null; String
				 * =countryDialingsArray.optString(""); String
				 * intialDialingCd=countryDialingsArray.optString(
				 * "intialDialingCd");
				 * if(countryDialingsArray.isNull("landPhMaxLthNbr")) {
				 * landPhMaxLthNbr = null; } else{
				 * landPhMaxLthNbr=countryDialingsArray.getInt("landPhMaxLthNbr"
				 * ); landPhMaxLthNbr1 = String.valueOf(landPhMaxLthNbr); }
				 *
				 * if(countryDialingsArray.isNull("landPhMinLthNbr")) {
				 * landPhMinLthNbr = null; } else{
				 * landPhMinLthNbr=countryDialingsArray.getInt("landPhMinLthNbr"
				 * ); landPhMinLthNbr1 = String.valueOf(landPhMinLthNbr); }
				 *
				 * if(countryDialingsArray.isNull("moblPhMaxLthNbr")) {
				 * moblPhMaxLthNbr = null; } else{
				 * moblPhMaxLthNbr=countryDialingsArray.getInt("moblPhMaxLthNbr"
				 * ); moblPhMaxLthNbr1 = String.valueOf(moblPhMaxLthNbr); }
				 *
				 * if(countryDialingsArray.isNull("moblPhMinLthNbr")) {
				 * moblPhMinLthNbr = null; } else{
				 * moblPhMinLthNbr=countryDialingsArray.getInt("moblPhMinLthNbr"
				 * ); moblPhMinLthNbr1 = String.valueOf(moblPhMinLthNbr); }
				 * String
				 * countryDialingsEffectiveDate=countryDialingsArray.optString(
				 * "effectiveDate"); String
				 * countryDialingsExpirationDate=countryDialingsArray.optString(
				 * "expirationDate");
				 */
				/**
				 * Create a JSON object of Currency and follow the same steps as
				 * above.
				 */
				JSONArray currency = getJMSResult.getJSONObject("data").getJSONArray("currencies");
				JSONObject currenciesArray = currency.getJSONObject(0);
				String moneyFormatDescription;
				String currencyNumericCode = currenciesArray.optString("currencyNumericCode");
				String currencyCode = currenciesArray.optString("currencyCode");
				Integer minorUnitCode = currenciesArray.optInt("minorUnitCode");
				if (currenciesArray.isNull("moneyFormatDescription")) {
					moneyFormatDescription = "";
				} else {
					moneyFormatDescription = currenciesArray.optString("moneyFormatDescription");
				}
				String currenciesEffectiveDate = currenciesArray.optString("effectiveDate");
				String currenciesExpirationDate = currenciesArray.optString("expirationDate");
				/**
				 * Create a JSON object of UoM Type and follow the same steps as
				 * above.
				 */
				JSONArray uomType = getJMSResult.getJSONObject("data").getJSONArray("geopoliticalUnitOfMeasures");
				JSONObject uomTypeArray = uomType.getJSONObject(0);
				String uomTypeCode = uomTypeArray.optString("uomTypeCode");
				String geopoliticalUnitOfMeasuresEffectiveDate = uomTypeArray.optString("effectiveDate");
				String geopoliticalUnitOfMeasuresExpirationDate = uomTypeArray.optString("expirationDate");
				/**
				 * Create a JSON object of Holiday and follow the same steps as
				 * above.
				 */
				JSONArray holidays = getJMSResult.getJSONObject("data").getJSONArray("geopoliticalHolidays");
				JSONObject holidaysArray = holidays.getJSONObject(0);
				String holidayName = holidaysArray.optString("holidayName");
				String geopoliticalHolidaysEffectiveDate = holidaysArray.optString("effectiveDate");
				String geopoliticalHolidaysExpirationDate = holidaysArray.optString("expirationDate");
				/**
				 * Create a JSON object of Affiliation Type and follow the same
				 * steps as above.
				 */
				JSONArray affilType = getJMSResult.getJSONObject("data").getJSONArray("geopoliticalAffiliations");
				JSONObject affilTypeArray = affilType.getJSONObject(0);
				String affilTypeName = affilTypeArray.optString("affiliationTypeName");
				String affiliationTypeCd = affilTypeArray.optString("affiliationTypeCode");
				String geopoliticalAffiliationsEffectiveDate = affilTypeArray.optString("effectiveDate");
				String geopoliticalAffiliationsExpirationDate = affilTypeArray.optString("expirationDate");
				/**
				 * Create a JSON object of Locale and follow the same steps as
				 * above.
				 */
				/*
				 * JSONArray locales =
				 * getJMSResult.getJSONObject("data").getJSONArray("locales");
				 * JSONObject localesArray = locales.getJSONObject(0); String
				 * localesLanguageCd, cldrVersionNumber, cldrVersionDate,
				 * dateFullFormatDescription, dateLongFormatDescription,
				 * dateMediumFormatDescription, dateShortFormatDescription;
				 * String localeEnglLanguageNm =
				 * localesArray.optString("engLanguageName"); String localeCode
				 * = localesArray.optString("localeCode"); String localeScrptCd
				 * = localesArray.optString("scriptCode"); if
				 * (localesArray.isNull("languageCode")) { localesLanguageCd =
				 * ""; } else { localesLanguageCd =
				 * localesArray.optString("languageCode"); } if
				 * (localesArray.isNull("cldrVersionNumber")) {
				 * cldrVersionNumber = ""; } else { cldrVersionNumber =
				 * localesArray.optString("cldrVersionNumber"); } if
				 * (localesArray.isNull("cldrVersionDate")) { cldrVersionDate =
				 * ""; } else { cldrVersionDate =
				 * localesArray.optString("cldrVersionDate"); } if
				 * (localesArray.isNull("dateFullFormatDescription")) {
				 * dateFullFormatDescription = ""; } else {
				 * dateFullFormatDescription =
				 * localesArray.optString("dateFullFormatDescription"); } if
				 * (localesArray.isNull("dateLongFormatDescription")) {
				 * dateLongFormatDescription = ""; } else {
				 * dateLongFormatDescription =
				 * localesArray.optString("dateLongFormatDescription"); } if
				 * (localesArray.isNull("dateMediumFormatDescription")) {
				 * dateMediumFormatDescription = ""; } else {
				 * dateMediumFormatDescription =
				 * localesArray.optString("dateMediumFormatDescription"); } if
				 * (localesArray.isNull("dateShortFormatDescription")) {
				 * dateShortFormatDescription = ""; } else {
				 * dateShortFormatDescription =
				 * localesArray.optString("dateShortFormatDescription"); }
				 * String localesEffectiveDate =
				 * localesArray.optString("effectiveDate"); String
				 * localesExpirationDate =
				 * localesArray.optString("expirationDate");
				 */
				/**
				 * Create a JSON object of Trnsl Geopolitical and follow the
				 * same steps as above.
				 */
				JSONArray trnslGeopl = getJMSResult.getJSONObject("data").getJSONArray("translationGeopoliticals");
				JSONObject trnslGeoplArray = trnslGeopl.getJSONObject(0);
				String trnslGeoplLanguageCd, translationName, versionNumber, versionDate;
				String trnslGeoplEnglLanguageNm = trnslGeoplArray.optString("engLanguageName");
				String trnslGeoplScriptCd = trnslGeoplArray.optString("scriptCode");
				if (trnslGeoplArray.isNull("translatedName")) {
					translationName = "";
				} else {
					translationName = trnslGeoplArray.optString("translatedName");
				}
				if (trnslGeoplArray.isNull("languageCode")) {
					trnslGeoplLanguageCd = "";
				} else {
					trnslGeoplLanguageCd = trnslGeoplArray.optString("languageCode");
				}
				if (trnslGeoplArray.isNull("versionNumber")) {
					versionNumber = "";
				} else {
					versionNumber = trnslGeoplArray.optString("versionNumber");
				}
				if (trnslGeoplArray.isNull("versionDate")) {
					versionDate = "";
				} else {
					versionDate = trnslGeoplArray.optString("versionDate");
				}
				String translationGeopoliticalsExpirationDate = trnslGeoplArray.optString("expirationDate");
				String translationGeopoliticalsEffectiveDate = trnslGeoplArray.optString("effectiveDate");

				Long geopoliticalTypeId;
				String geopoliticalTypeId1;
				if (getJMSResult.getJSONObject("data").getJSONObject("geopoliticalType").isNull("geopoliticalTypeId")) {
					// dependentRelationshipId = (Long) null;
					geopoliticalTypeId1 = "";
				} else {
					geopoliticalTypeId = getJMSResult.getJSONObject("data").getJSONObject("geopoliticalType")
							.getLong("geopoliticalTypeId");
					geopoliticalTypeId1 = String.valueOf(geopoliticalTypeId);
				}
				String geopoliticalTypeName = getJMSResult.getJSONObject("data").getJSONObject("geopoliticalType")
						.getString("geopoliticalTypeName");

				if (countryCode != null) {
					// ***get the DB query
					DateFormat srcDf = new SimpleDateFormat("yyyy-MM-dd");
					DateFormat destDf = new SimpleDateFormat("dd-MMM-yy");

					// Query1
					String formatCountryEffectiveDate = countryEffectiveDate;
					String formatCountryExpirationDate = countryExpirationDate;

					Date dateCountryEffectiveDate = null;
					Date dateCountryExpirationDate = null;

					try {
						dateCountryEffectiveDate = srcDf.parse(formatCountryEffectiveDate);
						dateCountryExpirationDate = srcDf.parse(formatCountryExpirationDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatCountryEffectiveDate = destDf.format(dateCountryEffectiveDate);
					formatCountryEffectiveDate = formatCountryEffectiveDate.toUpperCase();

					formatCountryExpirationDate = destDf.format(dateCountryExpirationDate);
					formatCountryExpirationDate = formatCountryExpirationDate.toUpperCase();

					String cntryPostPostQuery1 = query.cntryPostQuery(countryCode, geopoliticalId.toString(),
							formatCountryEffectiveDate, formatCountryExpirationDate);
					// ***get the fields needs to be validate in DB
					List<String> fields = ValidationFields.countryGetMethodDbFields();
					// ***get the result from DB
					List<String> getResultDB1 = DbConnect.getResultSetFor(cntryPostPostQuery1, fields, fileName,
							testCaseID);
					getResultDBFinal.addAll(getResultDB1);

					// Query 2
					/*
					 * String formatCountryDialingsEffectiveDate =
					 * countryDialingsEffectiveDate; Date
					 * dateCountryDialingsEffectiveDate = null;
					 *
					 * try { dateCountryDialingsEffectiveDate =
					 * srcDf.parse(formatCountryDialingsEffectiveDate); } catch
					 * (ParseException e) { // TODO Auto-generated catch block
					 * e.printStackTrace(); }
					 *
					 * formatCountryDialingsEffectiveDate =
					 * destDf.format(dateCountryDialingsEffectiveDate);
					 * formatCountryDialingsEffectiveDate =
					 * formatCountryDialingsEffectiveDate.toUpperCase();
					 *
					 *
					 * String cntryPostQuery2 =
					 * query.cntryCountryDialingsPostQuery(geopoliticalId.
					 * toString(),,formatCountryDialingsEffectiveDate); //***get
					 * the fields needs to be validate in DB List<String>
					 * fields2 =
					 * ValidationFields.countryDialGetMethodDbFields(); //***get
					 * the result from DB List<String> getResultDB2 =
					 * DbConnect.getResultSetFor(cntryPostQuery2, fields2,
					 * fileName, testCaseID); //***send the input, response, DB
					 * result for validation
					 * getResultDBFinal.addAll(getResultDB2);
					 */

					// Query 3--
					String formatCurrenciesEffectiveDate = currenciesEffectiveDate;
					String formatCurrenciesExpirationDate = currenciesExpirationDate;
					Date dateCurrenciesEffectiveDate = null;
					Date dateCurrenciesExpirationDate = null;
					try {
						dateCurrenciesEffectiveDate = srcDf.parse(formatCurrenciesEffectiveDate);
						dateCurrenciesExpirationDate = srcDf.parse(formatCurrenciesExpirationDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatCurrenciesEffectiveDate = destDf.format(dateCurrenciesEffectiveDate);
					formatCurrenciesExpirationDate = destDf.format(dateCurrenciesExpirationDate);

					formatCurrenciesEffectiveDate = formatCurrenciesEffectiveDate.toUpperCase();
					formatCurrenciesExpirationDate = formatCurrenciesExpirationDate.toUpperCase();

					String countryPostQuery3 = query.cntryCurrenciesPostQuery(geopoliticalId.toString(),
							currencyCode.toString(), minorUnitCode.toString(), formatCurrenciesEffectiveDate,
							formatCurrenciesExpirationDate);
					// ***get the fields needs to be validate in DB
					List<String> fields3 = ValidationFields.countryCurrencyGetMethodDbFields();
					// ***get the result from DB
					List<String> getResultDB3 = DbConnect.getResultSetFor(countryPostQuery3, fields3, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB3);

					// Query 4--
					String formatGeopoliticalUnitOfMeasuresEffectiveDate = geopoliticalUnitOfMeasuresEffectiveDate;
					Date dateGeopoliticalUnitOfMeasuresEffectiveDate = null;

					try {
						dateGeopoliticalUnitOfMeasuresEffectiveDate = srcDf
								.parse(formatGeopoliticalUnitOfMeasuresEffectiveDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatGeopoliticalUnitOfMeasuresEffectiveDate = destDf
							.format(dateGeopoliticalUnitOfMeasuresEffectiveDate);
					formatGeopoliticalUnitOfMeasuresEffectiveDate = formatGeopoliticalUnitOfMeasuresEffectiveDate
							.toUpperCase();

					String countryPostQuery4 = query.cntryGeopoliticalUOMPostQuery(geopoliticalId.toString(),
							formatGeopoliticalUnitOfMeasuresEffectiveDate);
					// ***get the fields needs to be validate in DB
					List<String> fields4 = ValidationFields.countryUomTypeGetMethodDbFields();
					// ***get the result from DB
					List<String> getResultDB4 = DbConnect.getResultSetFor(countryPostQuery4, fields4, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB4);

					// Query 5--
					String formatGeopoliticalHolidaysEffectiveDate = geopoliticalHolidaysEffectiveDate;
					Date dateGeopoliticalHolidaysEffectiveDate = null;

					try {
						dateGeopoliticalHolidaysEffectiveDate = srcDf.parse(formatGeopoliticalHolidaysEffectiveDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatGeopoliticalHolidaysEffectiveDate = destDf.format(dateGeopoliticalHolidaysEffectiveDate);
					formatGeopoliticalHolidaysEffectiveDate = formatGeopoliticalHolidaysEffectiveDate.toUpperCase();

					String countryPostQuery5 = query.cntryGeopoliticalHolidaysPostQuery(geopoliticalId.toString(),
							formatGeopoliticalHolidaysEffectiveDate);
					// ***get the fields needs to be validate in DB
					List<String> fields5 = ValidationFields.countryHolidayGetMethodDbFields();
					// ***get the result from DB
					List<String> getResultDB5 = DbConnect.getResultSetFor(countryPostQuery5, fields5, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB5);

					// Query 6--
					String formatGeopoliticalAffiliationsEffectiveDate = geopoliticalAffiliationsEffectiveDate;
					Date dateGeopoliticalAffiliationsEffectiveDate = null;

					try {
						dateGeopoliticalAffiliationsEffectiveDate = srcDf
								.parse(formatGeopoliticalAffiliationsEffectiveDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatGeopoliticalAffiliationsEffectiveDate = destDf
							.format(dateGeopoliticalAffiliationsEffectiveDate);
					formatGeopoliticalAffiliationsEffectiveDate = formatGeopoliticalAffiliationsEffectiveDate
							.toUpperCase();

					String countryPostQuery6 = query.countryAffilTypeJMSQuery(geopoliticalId.toString(),
							formatGeopoliticalAffiliationsEffectiveDate, geopoliticalAffiliationsExpirationDate);
					// ***get the fields needs to be validate in DB
					List<String> fields6 = ValidationFields.countryAffilTypeJMSDbFields();
					// ***get the result from DB
					List<String> getResultDB6 = DbConnect.getResultSetFor(countryPostQuery6, fields6, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB6);

					// Query 7--
					/*
					 * String formatLocalesEffectiveDate = localesEffectiveDate;
					 * Date dateLocalesEffectiveDate = null; String
					 * formatLocalesExpirationDate = localesExpirationDate; Date
					 * dateLocalesExpirationDate = null;
					 *
					 * try { dateLocalesEffectiveDate =
					 * srcDf.parse(formatLocalesEffectiveDate);
					 * dateLocalesExpirationDate =
					 * srcDf.parse(formatLocalesExpirationDate); } catch
					 * (ParseException e) { // TODO Auto-generated catch block
					 * e.printStackTrace(); }
					 *
					 * formatLocalesEffectiveDate =
					 * destDf.format(dateLocalesEffectiveDate);
					 * formatLocalesEffectiveDate =
					 * formatLocalesEffectiveDate.toUpperCase();
					 * formatLocalesExpirationDate =
					 * destDf.format(dateLocalesExpirationDate);
					 * formatLocalesExpirationDate =
					 * formatLocalesExpirationDate.toUpperCase();
					 *
					 * String countryPostQuery7 =
					 * query.countryLocaleJMSQuery(geopoliticalId.toString(),
					 * formatLocalesEffectiveDate, formatLocalesExpirationDate);
					 * // ***get the fields needs to be validate in DB
					 * List<String> fields7 =
					 * ValidationFields.countryLocaleJMSDbFields(); // ***get
					 * the result from DB List<String> getResultDB7 =
					 * DbConnect.getResultSetFor(countryPostQuery7, fields7,
					 * fileName, testCaseID); // ***send the input, response, DB
					 * result for validation
					 * getResultDBFinal.addAll(getResultDB7);
					 */

					// Query 8--
					String formatTranslationGeopoliticalsEffectiveDate = translationGeopoliticalsEffectiveDate;
					Date dateTranslationGeopoliticalsEffectiveDate = null;
					String formatTranslationGeopoliticalsExpirationDate = translationGeopoliticalsExpirationDate;
					Date dateTtanslationGeopoliticalsExpirationDate = null;

					try {
						dateTranslationGeopoliticalsEffectiveDate = srcDf
								.parse(formatTranslationGeopoliticalsEffectiveDate);
						dateTtanslationGeopoliticalsExpirationDate = srcDf
								.parse(formatTranslationGeopoliticalsExpirationDate);
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

					formatTranslationGeopoliticalsEffectiveDate = destDf
							.format(dateTranslationGeopoliticalsEffectiveDate);
					formatTranslationGeopoliticalsEffectiveDate = formatTranslationGeopoliticalsEffectiveDate
							.toUpperCase();
					formatTranslationGeopoliticalsExpirationDate = destDf
							.format(dateTtanslationGeopoliticalsExpirationDate);
					formatTranslationGeopoliticalsExpirationDate = formatTranslationGeopoliticalsExpirationDate
							.toUpperCase();

					String countryPostQuery8 = query.countryTrnslGeoplJMSQuery(geopoliticalId.toString(),
							formatTranslationGeopoliticalsEffectiveDate, formatTranslationGeopoliticalsExpirationDate);
					// ***get the fields needs to be validate in DB
					List<String> fields8 = ValidationFields.countryTrnslGeoplJMSDbFields();
					// ***get the result from DB
					List<String> getResultDB8 = DbConnect.getResultSetFor(countryPostQuery8, fields8, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB8);

					// Query 9--
					String countryPostQuery9 = query.countryGeopoliticalTypeJMSQuery(geopoliticalId.toString());
					// ***get the fields needs to be validate in DB
					List<String> fields9 = ValidationFields.geoTypeGetMethodDbFields();
					// ***get the result from DB
					List<String> getResultDB9 = DbConnect.getResultSetFor(countryPostQuery9, fields9, fileName,
							testCaseID);
					// ***send the input, response, DB result for validation
					getResultDBFinal.addAll(getResultDB9);

					String[] JMSValue = { geopoliticalId.toString(), countryNumericCode.toString(), countryCode,
							threeCharacterCountryCode, independentFlag, dependentRelationshipId1, dependentCountryCd1,
							postalFormatDescription, postalFlag, postalLengthNumber1, firstWorkWeekDayName,
							lastWorkWeekDayName, weekendFirstDayName, internetDomainName, intialDialingCd,
							landPhMaxLthNbr1, landPhMinLthNbr1, moblPhMaxLthNbr1, moblPhMinLthNbr1,
							countryEffectiveDate, countryExpirationDate, currencyNumericCode.toString(),
							currencyCode.toString(), minorUnitCode.toString(), moneyFormatDescription,
							currenciesEffectiveDate, currenciesExpirationDate, uomTypeCode,
							geopoliticalUnitOfMeasuresEffectiveDate, geopoliticalUnitOfMeasuresExpirationDate,
							holidayName, geopoliticalHolidaysEffectiveDate, geopoliticalHolidaysExpirationDate,
							affiliationTypeCd, affilTypeName, geopoliticalAffiliationsEffectiveDate,
							geopoliticalAffiliationsExpirationDate,
							/*
							 * localeEnglLanguageNm, localeCode, localeScrptCd,
							 * localesLanguageCd, cldrVersionDate,
							 * cldrVersionNumber, dateFullFormatDescription,
							 * dateLongFormatDescription,
							 * dateMediumFormatDescription,
							 * dateShortFormatDescription, localesEffectiveDate,
							 * localesExpirationDate,
							 */ trnslGeoplEnglLanguageNm, trnslGeoplScriptCd, translationName, trnslGeoplLanguageCd,
							versionDate, versionNumber, translationGeopoliticalsEffectiveDate,
							translationGeopoliticalsExpirationDate, geopoliticalTypeId1, geopoliticalTypeName };
					testResult = TestResultValidation.testValidationForJMS(JMSValue, getResultDBFinal);

					if (testResult) {
						// ***write result to excel
						String[] responseDbFieldValues = { geopoliticalId.toString(), getResultDBFinal.get(0),
								countryNumericCode.toString(), getResultDBFinal.get(1), countryCode,
								getResultDBFinal.get(2), threeCharacterCountryCode, getResultDBFinal.get(3),
								independentFlag, getResultDBFinal.get(4), dependentRelationshipId1,
								getResultDBFinal.get(5), dependentCountryCd1, getResultDBFinal.get(6),
								postalFormatDescription, getResultDBFinal.get(7), postalFlag, getResultDBFinal.get(8),
								postalLengthNumber1, getResultDBFinal.get(9), firstWorkWeekDayName,
								getResultDBFinal.get(10), lastWorkWeekDayName, getResultDBFinal.get(11),
								weekendFirstDayName, getResultDBFinal.get(12), internetDomainName,
								getResultDBFinal.get(13), intialDialingCd, getResultDBFinal.get(14), landPhMaxLthNbr1,
								getResultDBFinal.get(15), landPhMinLthNbr1, getResultDBFinal.get(16), moblPhMaxLthNbr1,
								getResultDBFinal.get(17), moblPhMinLthNbr1, getResultDBFinal.get(18),
								countryEffectiveDate, getResultDBFinal.get(19), countryExpirationDate,
								getResultDBFinal.get(20), currencyNumericCode.toString(), getResultDBFinal.get(21),
								currencyCode.toString(), getResultDBFinal.get(22), minorUnitCode.toString(),
								getResultDBFinal.get(23), moneyFormatDescription, getResultDBFinal.get(24),
								currenciesEffectiveDate, getResultDBFinal.get(25), currenciesExpirationDate,
								getResultDBFinal.get(26), uomTypeCode, getResultDBFinal.get(27),
								geopoliticalUnitOfMeasuresEffectiveDate, getResultDBFinal.get(28),
								geopoliticalUnitOfMeasuresExpirationDate, getResultDBFinal.get(29), holidayName,
								getResultDBFinal.get(30), geopoliticalHolidaysEffectiveDate, getResultDBFinal.get(31),
								geopoliticalHolidaysExpirationDate, getResultDBFinal.get(32), affiliationTypeCd,
								getResultDBFinal.get(33), affilTypeName, getResultDBFinal.get(34),
								geopoliticalAffiliationsEffectiveDate, getResultDBFinal.get(35),
								geopoliticalAffiliationsExpirationDate, getResultDBFinal.get(36),
								// localeCode, getResultDBFinal.get(38),
								// localeScrptCd,
								// getResultDBFinal.get(39), localesLanguageCd,
								// getResultDBFinal.get(40), cldrVersionDate,
								// getResultDBFinal.get(41), cldrVersionNumber,
								// getResultDBFinal.get(42),
								// dateFullFormatDescription,
								// getResultDBFinal.get(43),
								// dateLongFormatDescription,
								// getResultDBFinal.get(44),
								// dateMediumFormatDescription,
								// getResultDBFinal.get(45),
								// dateShortFormatDescription,
								// getResultDBFinal.get(46),
								// localesEffectiveDate,
								// getResultDBFinal.get(47),
								// localesExpirationDate,
								// getResultDBFinal.get(48),
								trnslGeoplScriptCd, getResultDBFinal.get(38), translationName, getResultDBFinal.get(39),
								trnslGeoplLanguageCd, getResultDBFinal.get(40), versionDate, getResultDBFinal.get(41),
								versionNumber, getResultDBFinal.get(42), translationGeopoliticalsEffectiveDate,
								getResultDBFinal.get(43), translationGeopoliticalsExpirationDate,
								getResultDBFinal.get(44), geopoliticalTypeName, getResultDBFinal.get(46) };
						String[] responseDbFieldNames = { "Response_geopoliticalId: ", "DB_geopoliticalId: ",
								"Response_countryNumberCd: ", "DB_countryNumberCd: ", "Response_countryCd: ",
								"DB_countryCd: ", "Response_threeCharCountryCd: ", "DB_threeCharCountryCd: ",
								"Response_independentFlag: ", "DB_independentFlag: ",
								"Response_dependentRelationshipId: ", "DB_dependentRelationshipId: ",
								"Response_dependentCountryCd: ", "DB_dependentCountryCd: ",
								"Response_postalFormatDescription: ", "DB_postalFormatDescription: ",
								"Response_postalFlag: ", "DB_postalFlag: ", "Response_postalLengthNumber: ",
								"DB_postalLengthNumber: ", "Response_firstWorkWeekDayName: ",
								"DB_firstWorkWeekDayName: ", "Response_lastWorkWeekDayName: ",
								"DB_lastWorkWeekDayName: ", "Response_weekendFirstDayName: ",
								"DB_weekendFirstDayName: ", "Response_internetDomainName: ", "DB_internetDomainName: ",
								"Response_intialDialingCd: ", "DB_intialDialingCd: ", "Response_landPhMaxLthNbr: ",
								"DB_landPhMaxLthNbr: ", "Response_landPhMinLthNbr: ", "DB_landPhMinLthNbr: ",
								"Response_moblPhMaxLthNbr: ", "DB_moblPhMaxLthNbr: ", "Response_moblPhMinLthNbr: ",
								"DB_moblPhMinLthNbrd: ", "Response_countryEffectiveDate: ", "DB_countryEffectiveDate: ",
								"Response_countryExpirationDate: ", "DB_countryExpirationDate: ",
								"Response_currencyNumberCd: ", "DB_currencyNumberCd: ", "Response_currencyCd: ",
								"DB_currencyCd: ", "Response_minorUnitCd: ", "DB_minorUnitCd: ",
								"Response_moneyFormatDescription: ", "DB_moneyFormatDescription: ",
								"Response_currenciesEffectiveDate: ", "DB_currenciesEffectiveDate: ",
								"Response_currenciesExpirationDate: ", "DB_currenciesExpirationDate: ",
								"Response_uomTypeCd: ", "DB_uomTypeCd: ",
								"Response_geopoliticalUnitOfMeasuresEffectiveDate: ",
								"DB_geopoliticalUnitOfMeasuresEffectiveDate: ",
								"Response_geopoliticalUnitOfMeasuresExpirationDate: ",
								"DB_geopoliticalUnitOfMeasuresExpirationDate: ", "Response_holidayName: ",
								"DB_holidayName: ", "Response_geopoliticalHolidaysEffectiveDate: ",
								"DB_geopoliticalHolidaysEffectiveDate: ",
								"Response_geopoliticalHolidaysExpirationDate: ",
								"DB_geopoliticalHolidaysExpirationDate: ", "Response_affilTypeCd: ", "DB_affilTypeCd: ",
								"Response_affilTypeNm: ", "DB_affilTypeNm: ",
								"Response_geopoliticalAffiliationsEffectiveDate: ",
								"DB_geopoliticalAffiliationsEffectiveDate: ",
								"Response_geopoliticalAffiliationsExpirationDate: ",
								"DB_geopoliticalAffiliationsExpirationDate: ", /*
																				 * "Response_localeCd: "
																				 * ,
																				 * "DB_localeCd: "
																				 * ,
																				 * "Response_localesScriptCd: "
																				 * ,
																				 * "DB_localesScriptCd: "
																				 * ,
																				 * "Response_localesLanguageCd: "
																				 * ,
																				 * "DB_localesLanguageCd: "
																				 * ,
																				 * "Response_cldrVersionDate: "
																				 * ,
																				 * "DB_cldrVersionDate: "
																				 * ,
																				 * "Response_cldrVersionNumber: "
																				 * ,
																				 * "DB_cldrVersionNumber: "
																				 * ,
																				 * "Response_dateFullFormatDescription: "
																				 * ,
																				 * "DB_dateFullFormatDescription: "
																				 * ,
																				 * "Response_dateLongFormatDescription: "
																				 * ,
																				 * "DB_dateLongFormatDescription: "
																				 * ,
																				 * "Response_dateMediumFormatDescription: "
																				 * ,
																				 * "DB_dateMediumFormatDescription: "
																				 * ,
																				 * "Response_dateShortFormatDescription: "
																				 * ,
																				 * "DB_dateShortFormatDescription: "
																				 * ,
																				 * "Response_localesEffectiveDate: "
																				 * ,
																				 * "DB_localesEffectiveDate: "
																				 * ,
																				 * "Response_localesExpirationDate: "
																				 * ,
																				 * "DB_localesExpirationDate: "
																				 * ,
																				 */
								"Response_translationGeopoliticalsScriptCd: ", "DB_translationGeopoliticalsScriptCd: ",
								"Response_translationName: ", "DB_translationName: ",
								"Response_translationGeopoliticalsLanguageCd: ",
								"DB_translationGeopoliticalsLanguageCdd: ", "Response_versionDate: ",
								"DB_versionDate: ", "Response_versionNumber: ", "DB_versionNumber: ",
								"Response_translationGeopoliticalsEffectiveDate: ",
								"DB_translationGeopoliticalsEffectiveDate: ",
								"Response_translationGeopoliticalsExpirationDate: ",
								"DB_translationGeopoliticalsExpirationDate: ", "Response_geopoliticalTypeName: ",
								"DB_geopoliticalTypeName: " };
						writableResult = Miscellaneous.geoFieldInputNames(responseDbFieldValues, responseDbFieldNames);

						logger.info("Comparison between JMS response & DB data matching and passed");
						logger.info("Execution is completed for Passed Test Case No. " + testCaseID);
						logger.info("------------------------------------------------------------------");
						test.pass("Comparison between JMS response & DB data matching and passed");
						test.pass(writableResult.replaceAll("\n", "<br />"));
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "NA", "", "", "", "",
								writableResult, "Pass", "");
						test.log(Status.PASS, MarkupHelper.createLabel("test status", ExtentColor.GREEN));
					} else {
						String[] responseDbFieldValues = { geopoliticalId.toString(), getResultDBFinal.get(0),
								countryNumericCode.toString(), getResultDBFinal.get(1), countryCode,
								getResultDBFinal.get(2), threeCharacterCountryCode, getResultDBFinal.get(3),
								independentFlag, getResultDBFinal.get(4), dependentRelationshipId1,
								getResultDBFinal.get(5), dependentCountryCd1, getResultDBFinal.get(6),
								postalFormatDescription, getResultDBFinal.get(7), postalFlag, getResultDBFinal.get(8),
								postalLengthNumber1, getResultDBFinal.get(9), firstWorkWeekDayName,
								getResultDBFinal.get(10), lastWorkWeekDayName, getResultDBFinal.get(11),
								weekendFirstDayName, getResultDBFinal.get(12), internetDomainName,
								getResultDBFinal.get(13), intialDialingCd, getResultDBFinal.get(14), landPhMaxLthNbr1,
								getResultDBFinal.get(15), landPhMinLthNbr1, getResultDBFinal.get(16), moblPhMaxLthNbr1,
								getResultDBFinal.get(17), moblPhMinLthNbr1, getResultDBFinal.get(18),
								countryEffectiveDate, getResultDBFinal.get(19), countryExpirationDate,
								getResultDBFinal.get(20), currencyNumericCode.toString(), getResultDBFinal.get(21),
								currencyCode.toString(), getResultDBFinal.get(22), minorUnitCode.toString(),
								getResultDBFinal.get(23), moneyFormatDescription, getResultDBFinal.get(24),
								currenciesEffectiveDate, getResultDBFinal.get(25), currenciesExpirationDate,
								getResultDBFinal.get(26), uomTypeCode, getResultDBFinal.get(27),
								geopoliticalUnitOfMeasuresEffectiveDate, getResultDBFinal.get(28),
								geopoliticalUnitOfMeasuresExpirationDate, getResultDBFinal.get(29), holidayName,
								getResultDBFinal.get(30), geopoliticalHolidaysEffectiveDate, getResultDBFinal.get(31),
								geopoliticalHolidaysExpirationDate, getResultDBFinal.get(32), affiliationTypeCd,
								getResultDBFinal.get(33), affilTypeName, getResultDBFinal.get(34),
								geopoliticalAffiliationsEffectiveDate, getResultDBFinal.get(35),
								geopoliticalAffiliationsExpirationDate, getResultDBFinal.get(36),
								/*
								 * localeCode, getResultDBFinal.get(38),
								 * localeScrptCd, getResultDBFinal.get(39),
								 * localesLanguageCd, getResultDBFinal.get(40),
								 * cldrVersionDate, getResultDBFinal.get(41),
								 * cldrVersionNumber, getResultDBFinal.get(42),
								 * dateFullFormatDescription,
								 * getResultDBFinal.get(43),
								 * dateLongFormatDescription,
								 * getResultDBFinal.get(44),
								 * dateMediumFormatDescription,
								 * getResultDBFinal.get(45),
								 * dateShortFormatDescription,
								 * getResultDBFinal.get(46),
								 * localesEffectiveDate,
								 * getResultDBFinal.get(47),
								 * localesExpirationDate,
								 * getResultDBFinal.get(48),
								 */
								trnslGeoplScriptCd, getResultDBFinal.get(38), translationName, getResultDBFinal.get(39),
								trnslGeoplLanguageCd, getResultDBFinal.get(40), versionDate, getResultDBFinal.get(41),
								versionNumber, getResultDBFinal.get(42), translationGeopoliticalsEffectiveDate,
								getResultDBFinal.get(43), translationGeopoliticalsExpirationDate,
								getResultDBFinal.get(44), geopoliticalTypeName, getResultDBFinal.get(46) };
						String[] responseDbFieldNames = { "Response_geopoliticalId: ", "DB_geopoliticalId: ",
								"Response_countryNumberCd: ", "DB_countryNumberCd: ", "Response_countryCd: ",
								"DB_countryCd: ", "Response_threeCharCountryCd: ", "DB_threeCharCountryCd: ",
								"Response_independentFlag: ", "DB_independentFlag: ",
								"Response_postalFormatDescription: ", "DB_postalFormatDescription: ",
								"Response_postalFlag: ", "DB_postalFlag: ", "Response_postalLengthNumber: ",
								"DB_postalLengthNumber: ", "Response_firstWorkWeekDayName: ",
								"DB_firstWorkWeekDayName: ", "Response_lastWorkWeekDayName: ",
								"DB_lastWorkWeekDayName: ", "Response_weekendFirstDayName: ",
								"DB_weekendFirstDayName: ", "Response_internetDomainName: ", "DB_internetDomainName: ",
								"Response_dependentRelationshipId: ", "DB_dependentRelationshipId: ",
								"Response_dependentCountryCd: ", "DB_dependentCountryCd: ",
								"Response_intialDialingCd: ", "DB_intialDialingCd: ", "Response_landPhMaxLthNbr: ",
								"DB_landPhMaxLthNbr: ", "Response_landPhMinLthNbr: ", "DB_landPhMinLthNbr: ",
								"Response_moblPhMaxLthNbr: ", "DB_moblPhMaxLthNbr: ", "Response_moblPhMinLthNbr: ",
								"DB_moblPhMinLthNbrd: ", "Response_countryEffectiveDate: ", "DB_countryEffectiveDate: ",
								"Response_countryExpirationDate: ", "DB_countryExpirationDate: ",
								"Response_currencyNumberCd: ", "DB_currencyNumberCd: ", "Response_currencyCd: ",
								"DB_currencyCd: ", "Response_minorUnitCd: ", "DB_minorUnitCd: ",
								"Response_moneyFormatDescription: ", "DB_moneyFormatDescription: ",
								"Response_currenciesEffectiveDate: ", "DB_currenciesEffectiveDate: ",
								"Response_currenciesExpirationDate: ", "DB_currenciesExpirationDate: ",
								"Response_uomTypeCd: ", "DB_uomTypeCd: ",
								"Response_geopoliticalUnitOfMeasuresEffectiveDate: ",
								"DB_geopoliticalUnitOfMeasuresEffectiveDate: ",
								"Response_geopoliticalUnitOfMeasuresExpirationDate: ",
								"DB_geopoliticalUnitOfMeasuresExpirationDate: ", "Response_holidayName: ",
								"DB_holidayName: ", "Response_geopoliticalHolidaysEffectiveDate: ",
								"DB_geopoliticalHolidaysEffectiveDate: ",
								"Response_geopoliticalHolidaysExpirationDate: ",
								"DB_geopoliticalHolidaysExpirationDate: ", "Response_affilTypeCd: ", "DB_affilTypeCd: ",
								"Response_affilTypeNm: ", "DB_affilTypeNm: ",
								"Response_geopoliticalAffiliationsEffectiveDate: ",
								"DB_geopoliticalAffiliationsEffectiveDate: ",
								"Response_geopoliticalAffiliationsExpirationDate: ",
								"DB_geopoliticalAffiliationsExpirationDate: ", /*
																				 * "Response_localesLanguageCd: "
																				 * ,
																				 * "DB_localesLanguageCd: "
																				 * ,
																				 * "Response_localeCd: "
																				 * ,
																				 * "DB_localeCd: "
																				 * ,
																				 * "Response_localesScriptCd: "
																				 * ,
																				 * "DB_localesScriptCd: "
																				 * ,
																				 * "Response_cldrVersionNumber: "
																				 * ,
																				 * "DB_cldrVersionNumber: "
																				 * ,
																				 * "Response_cldrVersionDate: "
																				 * ,
																				 * "DB_cldrVersionDate: "
																				 * ,
																				 * "Response_dateFullFormatDescription: "
																				 * ,
																				 * "DB_dateFullFormatDescription: "
																				 * ,
																				 * "Response_dateLongFormatDescription: "
																				 * ,
																				 * "DB_dateLongFormatDescription: "
																				 * ,
																				 * "Response_dateMediumFormatDescription: "
																				 * ,
																				 * "DB_dateMediumFormatDescription: "
																				 * ,
																				 * "Response_dateShortFormatDescription: "
																				 * ,
																				 * "DB_dateShortFormatDescription: "
																				 * ,
																				 * "Response_localesEffectiveDate: "
																				 * ,
																				 * "DB_localesEffectiveDate: "
																				 * ,
																				 * "Response_localesExpirationDate: "
																				 * ,
																				 * "DB_localesExpirationDate: "
																				 * ,
																				 */
								"Response_translationGeopoliticalsLanguageCd: ",
								"DB_translationGeopoliticalsLanguageCdd: ",
								"Response_translationGeopoliticalsScriptCd: ", "DB_translationGeopoliticalsScriptCd: ",
								"Response_translationName: ", "DB_translationName: ", "Response_versionNumber: ",
								"DB_versionNumber: ", "Response_versionDate: ", "DB_versionDate: ",
								"Response_translationGeopoliticalsEffectiveDate: ",
								"DB_translationGeopoliticalsEffectiveDate: ",
								"Response_translationGeopoliticalsExpirationDate: ",
								"DB_translationGeopoliticalsExpirationDate: ", "Response_geopoliticalTypeName: ",
								"DB_geopoliticalTypeName: " };
						writableResult = Miscellaneous.geoFieldInputNames(responseDbFieldValues, responseDbFieldNames);
						logger.error("Comparison between JMS & DB data not matching and failed");
						logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
						logger.error("------------------------------------------------------------------");
						test.fail("Comparison between input data & DB data not matching and failed");
						test.fail("Comparison between input data & DB data not matching and failed");
						ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "NA", "", "", "", "",
								writableResult, "Fail", "Comparison between JMS & DB data not matching and failed");
						Assert.fail("Test Failed");
					}
				} else {
					logger.error("Country Cd is not available in response");
					logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
					logger.error("------------------------------------------------------------------");
					test.fail("Country Cd is not available in response");
					ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "",
							"Fail", "");
					Assert.fail("Test Failed");
				}
			} else {
				logger.error("Posted request is not reached to JMS queue");
				logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
				logger.error("------------------------------------------------------------------");
				test.fail("Posted request is not reached to JMS queue");
				ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
						"");
				Assert.fail("Test Failed");
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception thrown when executing the test case: " + e);
			logger.error("Execution is completed for Failed Test Case No. " + testCaseID);
			logger.error("------------------------------------------------------------------");
			test.fail("Exception thrown when executing the test case: " + e);
			ex.writeExcel(fileName, testCaseID, TestCaseDescription, scenarioType, "", "", "", "", "", "", "Fail",
					"" + e);
			Assert.fail("Test Failed");
		}
	}

	// ***get the values from test data sheet
	public void testDataFields(String scenarioName, String testCaseId) {
		HashMap<String, LinkedHashMap<String, String>> inputData1 = null;
		try {
			inputData1 = ex.getTestData(scenarioName);
		} catch (IOException e) {
			e.printStackTrace();
			ex.writeExcel(fileName, testCaseId, "", "", "", "", "", "", "", "", "Fail", "Exception: " + e.toString());
			test.fail("Unable to retrieve the test data file/fields");
		}
		TestCaseDescription = inputData1.get(testCaseId).get("TestCaseDescription");
		scenarioType = inputData1.get(testCaseId).get("Scenario Type");
		userId = inputData1.get(testCaseId).get("UserName");
		countryNumericCode = inputData1.get(testCaseId).get("countryNumberCd");
		countryCode = inputData1.get(testCaseId).get("countryCd");
		threeCharacterCountryCode = inputData1.get(testCaseId).get("threeCharCountryCd");
		independentFlag = inputData1.get(testCaseId).get("independentFlag");
		postalFormatDescription = inputData1.get(testCaseId).get("postalFormatDescription");
		postalFlag = inputData1.get(testCaseId).get("postalFlag");
		postalLengthNumber = inputData1.get(testCaseId).get("postalLengthNumber");
		firstWorkWeekDayName = inputData1.get(testCaseId).get("firstWorkWeekDayName");
		lastWorkWeekDayName = inputData1.get(testCaseId).get("lastWorkWeekDayName");
		weekendFirstDayName = inputData1.get(testCaseId).get("weekendFirstDayName");
		internetDomainName = inputData1.get(testCaseId).get("internetDomainName");
		dependentRelationshipId = inputData1.get(testCaseId).get("dependentRelationshipId");
		dependentCountryCode = inputData1.get(testCaseId).get("dependentCountryCd");
		countryEffectiveDate = inputData1.get(testCaseId).get("countryEffectiveDate");
		countryExpirationDate = inputData1.get(testCaseId).get("countryExpirationDate");
		// intialDialingPrefixCd =
		// inputData1.get(testCaseId).get("intialDialingPrefixCd");
		intialDialingCd = inputData1.get(testCaseId).get("intialDialingCd");
		landPhMaxLthNbr = inputData1.get(testCaseId).get("landPhMaxLthNbr");
		landPhMinLthNbr = inputData1.get(testCaseId).get("landPhMinLthNbr");
		moblPhMaxLthNbr = inputData1.get(testCaseId).get("moblPhMaxLthNbr");
		moblPhMinLthNbr = inputData1.get(testCaseId).get("moblPhMinLthNbr");
		// countryDialingsEffectiveDate =
		// inputData1.get(testCaseId).get("countryDialingsEffectiveDate");
		// countryDialingsExpirationDate =
		// inputData1.get(testCaseId).get("countryDialingsExpirationDate");
		currencyNumericCode = inputData1.get(testCaseId).get("currencyNumberCd");
		currencyCode = inputData1.get(testCaseId).get("currencyCd");
		minorUnitCode = inputData1.get(testCaseId).get("minorUnitCd");
		moneyFormatDescription = inputData1.get(testCaseId).get("moneyFormatDescription");
		currenciesEffectiveDate = inputData1.get(testCaseId).get("currenciesEffectiveDate");
		currenciesExpirationDate = inputData1.get(testCaseId).get("currenciesExpirationDate");
		uomTypeCode = inputData1.get(testCaseId).get("uomTypeCd");
		geopoliticalUnitOfMeasuresEffectiveDate = inputData1.get(testCaseId)
				.get("geopoliticalUnitOfMeasuresEffectiveDate");
		geopoliticalUnitOfMeasuresExpirationDate = inputData1.get(testCaseId)
				.get("geopoliticalUnitOfMeasuresExpirationDate");
		holidayName = inputData1.get(testCaseId).get("holidayName");
		geopoliticalHolidaysEffectiveDate = inputData1.get(testCaseId).get("geopoliticalHolidaysEffectiveDate");
		geopoliticalHolidaysExpirationDate = inputData1.get(testCaseId).get("geopoliticalHolidaysExpirationDate");
		affiliationTypeCd = inputData1.get(testCaseId).get("affilTypeCd");
		geopoliticalAffiliationsEffectiveDate = inputData1.get(testCaseId).get("geopoliticalAffiliationsEffectiveDate");
		geopoliticalAffiliationsExpirationDate = inputData1.get(testCaseId)
				.get("geopoliticalAffiliationsExpirationDate");
		localesLanguageCd = inputData1.get(testCaseId).get("localesLanguageCd");
		localeCode = inputData1.get(testCaseId).get("localeCd");
		localesScriptCd = inputData1.get(testCaseId).get("localesScriptCd");
		cldrVersionNumber = inputData1.get(testCaseId).get("cldrVersionNumber");
		cldrVersionDate = inputData1.get(testCaseId).get("cldrVersionDate");
		dateFullFormatDescription = inputData1.get(testCaseId).get("dateFullFormatDescription");
		dateLongFormatDescription = inputData1.get(testCaseId).get("dateLongFormatDescription");
		dateMediumFormatDescription = inputData1.get(testCaseId).get("dateMediumFormatDescription");
		dateShortFormatDescription = inputData1.get(testCaseId).get("dateShortFormatDescription");
		localesEffectiveDate = inputData1.get(testCaseId).get("localesEffectiveDate");
		localesExpirationDate = inputData1.get(testCaseId).get("localesExpirationDate");
		translationGeopoliticalsLanguageCd = inputData1.get(testCaseId).get("translationGeopoliticalsLanguageCd");
		translationGeopoliticalsScriptCd = inputData1.get(testCaseId).get("translationGeopoliticalsScriptCd");
		translationName = inputData1.get(testCaseId).get("translationName");
		versionNumber = inputData1.get(testCaseId).get("versionNumber");
		versionDate = inputData1.get(testCaseId).get("versionDate");
		translationGeopoliticalsEffectiveDate = inputData1.get(testCaseId).get("translationGeopoliticalsEffectiveDate");
		translationGeopoliticalsExpirationDate = inputData1.get(testCaseId)
				.get("translationGeopoliticalsExpirationDate");
		geopoliticalTypeName = inputData1.get(testCaseId).get("geopoliticalTypeName");
		phoneNumberFormatPattern = inputData1.get(testCaseId).get("phoneNumberFormatPattern");

	}
}
